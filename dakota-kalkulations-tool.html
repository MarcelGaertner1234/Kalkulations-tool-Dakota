<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dakota Kalkulations-Tool | Professional Food Cost Management</title>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Lato:wght@300;400;700&display=swap"
        rel="stylesheet">

    <!-- jsPDF for PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- Firebase SDK v9 (Modular) -->
    <script type="module">
        // Firebase v9 Modular SDK
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getFirestore, collection, doc, setDoc, getDoc, getDocs, deleteDoc, onSnapshot, query, orderBy } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBcJIxRaSEgZ81zgbS0ABPrshHnWi7WeII",
            authDomain: "dakota-485ec.firebaseapp.com",
            projectId: "dakota-485ec",
            storageBucket: "dakota-485ec.firebasestorage.app",
            messagingSenderId: "167881815096",
            appId: "1:167881815096:web:4f21dc27bcf1ad7dcc62cd",
            measurementId: "G-C40N5JEB9E"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const firestoreDB = getFirestore(app);
        const auth = getAuth(app);

        // Export to global scope for use in main script
        window.firebaseApp = app;
        window.firestoreDB = firestoreDB;
        window.firebaseAuth = auth;
        window.firebaseModules = {
            collection, doc, setDoc, getDoc, getDocs, deleteDoc, onSnapshot, query, orderBy,
            signInAnonymously, onAuthStateChanged
        };

        console.log('‚úÖ Firebase initialized successfully');
    </script>

    <style>
        /* ===== RESET & BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --dakota-gold: #dba765;
            --dakota-dark: #32373c;
            --dakota-light: #f5f5f5;
            --dakota-white: #ffffff;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --info: #17a2b8;
        }

        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            color: var(--dakota-dark);
            line-height: 1.6;
            min-height: 100vh;
        }

        h1,
        h2,
        h3,
        h4 {
            font-family: 'Playfair Display', serif;
            color: var(--dakota-dark);
        }

        /* ===== HEADER ===== */
        .header {
            background: linear-gradient(135deg, var(--dakota-dark) 0%, #1a1d20 100%);
            color: var(--dakota-gold);
            padding: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Playfair Display', serif;
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .header-stats {
            display: flex;
            gap: 2rem;
            font-size: 0.9rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--dakota-gold);
        }

        .stat-label {
            color: #999;
            font-size: 0.85rem;
        }

        /* ===== GLOBAL SEARCH ===== */
        .global-search-container {
            position: relative;
            margin-left: 2rem;
        }

        .global-search-input {
            width: 300px;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            border: 2px solid rgba(219, 167, 101, 0.3);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .global-search-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .global-search-input:focus {
            outline: none;
            border-color: var(--dakota-gold);
            background: rgba(255, 255, 255, 0.15);
            width: 350px;
        }

        .global-search-icon {
            position: absolute;
            left: 0.85rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 1rem;
        }

        .global-search-results {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: var(--dakota-white);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-height: 400px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
        }

        .global-search-results.active {
            display: block;
        }

        .search-result-group {
            padding: 0.5rem 0;
            border-bottom: 1px solid #eee;
        }

        .search-result-group:last-child {
            border-bottom: none;
        }

        .search-result-group-title {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #999;
            background: #f8f8f8;
        }

        .search-result-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transition: background 0.2s;
            color: var(--dakota-dark);
        }

        .search-result-item:hover {
            background: rgba(219, 167, 101, 0.1);
        }

        .search-result-icon {
            font-size: 1.2rem;
        }

        .search-result-info {
            flex: 1;
        }

        .search-result-name {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .search-result-detail {
            font-size: 0.8rem;
            color: #888;
        }

        .search-result-badge {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            background: var(--dakota-gold);
            color: white;
        }

        .search-no-results {
            padding: 1.5rem;
            text-align: center;
            color: #999;
        }

        .search-shortcut {
            font-size: 0.7rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-left: 0.5rem;
            color: rgba(255, 255, 255, 0.6);
        }

        /* ===== DRAG & DROP ===== */
        .draggable-row {
            cursor: grab;
            transition: all 0.2s ease;
        }

        .draggable-row:active {
            cursor: grabbing;
        }

        .draggable-row.dragging {
            opacity: 0.5;
            background: rgba(219, 167, 101, 0.2) !important;
        }

        .draggable-row.drag-over {
            border-top: 3px solid var(--dakota-gold) !important;
        }

        .drag-handle {
            cursor: grab;
            padding: 0.5rem;
            color: #999;
            font-size: 1.2rem;
            user-select: none;
        }

        .drag-handle:hover {
            color: var(--dakota-gold);
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* ===== SAISONKALENDER ===== */
        .saison-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .saison-badge.in-saison {
            background: rgba(40, 167, 69, 0.15);
            color: #28a745;
        }

        .saison-badge.off-saison {
            background: rgba(220, 53, 69, 0.15);
            color: #dc3545;
        }

        .saison-badge.bald-saison {
            background: rgba(255, 193, 7, 0.15);
            color: #856404;
        }

        .saison-filter-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .saison-filter-btn {
            padding: 0.4rem 0.8rem;
            border: 2px solid #ddd;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .saison-filter-btn:hover {
            border-color: var(--dakota-gold);
        }

        .saison-filter-btn.active {
            background: var(--dakota-gold);
            border-color: var(--dakota-gold);
            color: white;
        }

        .saison-checkbox {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.5rem;
            background: #f5f5f5;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .saison-checkbox:hover {
            background: rgba(219, 167, 101, 0.2);
        }

        .saison-checkbox input:checked + span,
        .saison-checkbox:has(input:checked) {
            background: var(--dakota-gold);
            color: white;
        }

        /* ===== LIEFERSCHEIN SCANNER ===== */
        .settings-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .settings-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .api-key-container {
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
        }

        .api-key-input-wrapper {
            flex: 1;
            position: relative;
        }

        .api-key-input {
            width: 100%;
            padding: 0.75rem 2.5rem 0.75rem 1rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.95rem;
        }

        .api-key-input:focus {
            outline: none;
            border-color: var(--dakota-gold);
        }

        .api-key-toggle {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            opacity: 0.6;
        }

        .api-key-toggle:hover {
            opacity: 1;
        }

        .api-key-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        .api-key-status.saved {
            color: #28a745;
        }

        .api-key-status.missing {
            color: #dc3545;
        }

        .upload-zone {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #fafafa 0%, #f0f0f0 100%);
        }

        .upload-zone:hover {
            border-color: var(--dakota-gold);
            background: linear-gradient(135deg, #fff 0%, #fdf8f3 100%);
        }

        .upload-zone.dragover {
            border-color: var(--dakota-gold);
            background: rgba(219, 167, 101, 0.1);
            transform: scale(1.01);
        }

        .upload-zone-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        .upload-zone-text {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .upload-zone-hint {
            font-size: 0.9rem;
            color: #999;
        }

        .upload-preview {
            margin-top: 1.5rem;
            display: none;
        }

        .upload-preview.active {
            display: block;
        }

        .preview-image-container {
            max-width: 400px;
            margin: 0 auto 1rem;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .preview-image {
            width: 100%;
            display: block;
        }

        .scanner-results {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .scanner-results-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .scanner-product-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .scanner-product-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .scanner-product-item:hover {
            background: #f8f9fa;
        }

        .scanner-product-item:last-child {
            border-bottom: none;
        }

        .scanner-product-name {
            font-weight: 500;
        }

        .scanner-product-price {
            font-weight: 600;
            color: var(--dakota-gold);
        }

        .scanner-product-status {
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .scanner-product-status.match {
            background: rgba(40, 167, 69, 0.15);
            color: #28a745;
        }

        .scanner-product-status.new {
            background: rgba(23, 162, 184, 0.15);
            color: #17a2b8;
        }

        .scanner-product-status.update {
            background: rgba(255, 193, 7, 0.15);
            color: #856404;
        }

        .scanner-loading {
            text-align: center;
            padding: 2rem;
        }

        .scanner-loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(219, 167, 101, 0.3);
            border-top-color: var(--dakota-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        /* ===== NAVIGATION TABS ===== */
        .nav-tabs {
            background: var(--dakota-white);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 100px;
            z-index: 999;
        }

        .tabs-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 0;
        }

        .tab-button {
            flex: 1;
            padding: 1.25rem 2rem;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .tab-button:hover {
            background: rgba(219, 167, 101, 0.1);
            color: var(--dakota-gold);
        }

        .tab-button.active {
            color: var(--dakota-gold);
            border-bottom-color: var(--dakota-gold);
            background: rgba(219, 167, 101, 0.05);
        }

        .tab-icon {
            font-size: 1.2rem;
        }

        /* ===== MAIN CONTENT ===== */
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== CARDS ===== */
        .card {
            background: var(--dakota-white);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.12);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--dakota-gold);
        }

        .card-title {
            font-size: 1.5rem;
            color: var(--dakota-dark);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* ===== BUTTONS ===== */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--dakota-gold);
            color: var(--dakota-white);
        }

        .btn-primary:hover {
            background: #c89654;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(219, 167, 101, 0.3);
        }

        .btn-secondary {
            background: var(--dakota-dark);
            color: var(--dakota-white);
        }

        .btn-secondary:hover {
            background: #1a1d20;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        /* ===== FORM ELEMENTS ===== */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--dakota-dark);
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Lato', sans-serif;
            transition: all 0.3s ease;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--dakota-gold);
            box-shadow: 0 0 0 3px rgba(219, 167, 101, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        /* ===== TABLE ===== */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .data-table th {
            background: var(--dakota-dark);
            color: var(--dakota-gold);
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 3px solid var(--dakota-gold);
        }

        .data-table td {
            padding: 1rem;
            border-bottom: 1px solid #eee;
        }

        .data-table tr:hover {
            background: rgba(219, 167, 101, 0.05);
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* ===== BADGES ===== */
        .badge {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .badge-success {
            background: var(--success);
            color: white;
        }

        .badge-warning {
            background: var(--warning);
            color: var(--dakota-dark);
        }

        .badge-danger {
            background: var(--danger);
            color: white;
        }

        .badge-info {
            background: var(--info);
            color: white;
        }

        .badge-gold {
            background: var(--dakota-gold);
            color: white;
        }

        /* ===== MODAL ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--dakota-gold);
        }

        .modal-close {
            background: transparent;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #999;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--danger);
        }

        /* ===== SEARCH & FILTER ===== */
        .search-bar {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .search-input {
            width: 100%;
            padding: 1rem 1rem 1rem 3rem;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 1rem;
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
        }

        /* ===== AUTOCOMPLETE COMPONENT ===== */
        .autocomplete-container {
            position: relative;
            flex: 2;
        }

        .autocomplete-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Lato', sans-serif;
            transition: all 0.3s ease;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: var(--dakota-gold);
            box-shadow: 0 0 0 3px rgba(219, 167, 101, 0.1);
        }

        .autocomplete-input.has-selection {
            background-color: #f0f8f0;
            border-color: #4CAF50;
            font-weight: 600;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: white;
            border: 2px solid var(--dakota-gold);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            margin-top: 0.25rem;
            display: none;
        }

        .autocomplete-dropdown.active {
            display: block;
        }

        .autocomplete-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background-color: rgba(219, 167, 101, 0.1);
        }

        .autocomplete-item-name {
            font-weight: 600;
            color: #2c3e50;
        }

        .autocomplete-item-category {
            font-size: 0.85rem;
            color: #7f8c8d;
            margin-left: 0.5rem;
        }

        .autocomplete-no-results {
            padding: 1rem;
            text-align: center;
            color: #999;
            font-style: italic;
        }

        /* ===== FOOD COST INDICATOR ===== */
        .food-cost-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 700;
        }

        .food-cost-excellent {
            background: #d4edda;
            color: #155724;
        }

        .food-cost-good {
            background: #fff3cd;
            color: #856404;
        }

        .food-cost-warning {
            background: #f8d7da;
            color: #721c24;
        }

        /* ===== LOADING SPINNER ===== */
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(219, 167, 101, 0.3);
            border-top-color: var(--dakota-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* ===== DIENSTPLAN ===== */
        .dienstplan-layout {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }

        .diensttypen-palette {
            width: 160px;
            flex-shrink: 0;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            position: sticky;
            top: 180px;
        }

        .diensttypen-palette h4 {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            color: var(--dakota-dark);
        }

        .palette-items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .palette-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: white;
            border-radius: 6px;
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            border: 1px solid #eee;
        }

        .palette-item:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .palette-item:active {
            cursor: grabbing;
        }

        .palette-item .schicht-badge {
            flex-shrink: 0;
        }

        .palette-item-name {
            font-size: 0.75rem;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Drag States */
        .dragging {
            opacity: 0.5;
        }

        .dienstplan-cell.drag-over {
            background: rgba(219, 167, 101, 0.3) !important;
            outline: 2px dashed var(--dakota-gold);
            outline-offset: -2px;
        }

        .schicht-badge.draggable {
            cursor: grab;
        }

        .schicht-badge.draggable:active {
            cursor: grabbing;
        }

        /* Fill-Handle (kleines Quadrat zum Durchziehen wie in Excel) */
        .fill-handle {
            position: absolute;
            right: -3px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: var(--dakota-gold);
            border: 1px solid #fff;
            border-radius: 2px;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
        }

        .schicht-badge:hover .fill-handle {
            opacity: 1;
        }

        /* Markierung w√§hrend Fill-Drag */
        .dienstplan-cell.fill-preview {
            background: rgba(219, 167, 101, 0.4) !important;
            outline: 2px solid var(--dakota-gold);
            outline-offset: -2px;
        }

        .dienstplan-container {
            overflow-x: auto;
            margin: 1rem 0;
            flex: 1;
        }

        .dienstplan-kalender {
            display: grid;
            /* min-width wird dynamisch via JavaScript gesetzt */
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        .dienstplan-header {
            display: contents;
        }

        .dienstplan-header-cell {
            background: var(--dakota-dark);
            color: var(--dakota-gold);
            padding: 0.5rem 0.25rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.75rem;
            border-right: 1px solid #555;
        }

        .dienstplan-header-cell.name-col {
            min-width: 120px;
            text-align: left;
            padding-left: 0.75rem;
        }

        .dienstplan-header-cell.wt-col {
            min-width: 35px;
        }

        .dienstplan-header-cell.day-col {
            min-width: 40px;
        }

        .dienstplan-header-cell.weekend {
            background: #4a4f54;
        }

        .dienstplan-row {
            display: contents;
        }

        .dienstplan-cell {
            padding: 0.4rem 0.25rem;
            text-align: center;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
            font-size: 0.8rem;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .dienstplan-cell:hover {
            background: rgba(219, 167, 101, 0.1);
        }

        .dienstplan-cell.name-cell {
            justify-content: flex-start;
            padding-left: 0.75rem;
            font-weight: 600;
            background: #f8f9fa;
            cursor: default;
        }

        .dienstplan-cell.name-cell:hover {
            background: #f8f9fa;
        }

        .dienstplan-cell.wt-cell {
            font-size: 0.7rem;
            color: #888;
            cursor: default;
        }

        .dienstplan-cell.wt-cell:hover {
            background: transparent;
        }

        .dienstplan-cell.std-cell {
            font-size: 0.7rem;
            color: #27ae60;
            font-weight: bold;
            background: #f0fff4;
            cursor: default;
        }

        .dienstplan-cell.std-cell:hover {
            background: #f0fff4;
        }

        .dienstplan-header-cell.std-col {
            background: #e8f5e9;
        }

        .dienstplan-cell.weekend {
            background: #f5f5f5;
        }

        .dienstplan-cell.day-number {
            font-weight: 600;
            background: #e9ecef;
            cursor: default;
        }

        .dienstplan-cell.day-number:hover {
            background: #e9ecef;
        }

        /* Schicht-Badges */
        .schicht-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 24px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 0.75rem;
            color: white;
        }

        .schicht-f {
            background: #3498db;
        }

        .schicht-s {
            background: #e67e22;
        }

        .schicht-x {
            background: #95a5a6;
        }

        .schicht-w {
            background: #bdc3c7;
            color: #555;
        }

        .schicht-k {
            background: #e74c3c;
        }

        .schicht-sp {
            background: #f1c40f;
            color: #333;
        }

        .schicht-hp {
            background: #27ae60;
        }

        .schicht-fe {
            background: #9b59b6;
        }

        .schicht-leer {
            background: #ecf0f1;
            color: #999;
        }

        /* Legende */
        .dienstplan-legende {
            margin-top: 1.5rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legende-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 0.75rem;
        }

        .legende-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        /* Mitarbeiter Liste */
        .mitarbeiter-liste {
            max-height: 400px;
            overflow-y: auto;
        }

        .mitarbeiter-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .mitarbeiter-item:hover {
            background: #f8f9fa;
        }

        .mitarbeiter-info {
            display: flex;
            flex-direction: column;
        }

        .mitarbeiter-name {
            font-weight: 600;
        }

        .mitarbeiter-rolle {
            font-size: 0.85rem;
            color: #888;
        }

        .mitarbeiter-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Schicht-Auswahl Modal */
        .schicht-auswahl {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            padding: 1rem 0;
        }

        .schicht-btn {
            padding: 1rem;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.2s;
            color: white;
        }

        .schicht-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .schicht-btn small {
            display: block;
            font-size: 0.7rem;
            font-weight: 400;
            margin-top: 0.25rem;
        }

        /* Diensttypen Liste */
        .diensttypen-liste {
            max-height: 400px;
            overflow-y: auto;
        }

        .diensttyp-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .diensttyp-item:hover {
            background: #f8f9fa;
        }

        .diensttyp-preview {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .diensttyp-info {
            display: flex;
            flex-direction: column;
        }

        .diensttyp-name {
            font-weight: 600;
        }

        .diensttyp-zeit {
            font-size: 0.8rem;
            color: #888;
        }

        .diensttyp-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Farbpicker */
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .color-picker-wrapper input[type="color"] {
            width: 50px;
            height: 36px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }

            .tabs-container {
                flex-direction: column;
            }

            .tab-button {
                border-bottom: 1px solid #eee;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .data-table {
                font-size: 0.9rem;
            }

            .data-table th,
            .data-table td {
                padding: 0.75rem 0.5rem;
            }
        }

        /* ===== EMPTY STATE ===== */
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: #999;
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
        }

        /* ===== ACTION BUTTONS IN TABLE ===== */
        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .btn-icon {
            padding: 0.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.2rem;
            color: #666;
            transition: all 0.3s ease;
        }

        .btn-icon:hover {
            color: var(--dakota-gold);
            transform: scale(1.1);
        }

        .btn-icon.delete:hover {
            color: var(--danger);
        }

        /* ===== DRAG & DROP STYLES ===== */
        .draggable-row {
            cursor: grab;
            transition: all 0.2s ease;
        }
        .draggable-row:active {
            cursor: grabbing;
        }
        .draggable-row.dragging {
            opacity: 0.5;
            background: #fff3cd !important;
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .draggable-row.drag-over {
            border-top: 3px solid var(--dakota-gold) !important;
            background: rgba(196, 164, 105, 0.1);
        }
        .drag-handle {
            cursor: grab;
            padding: 0.3rem 0.5rem;
            color: #999;
            font-size: 1.2rem;
            user-select: none;
        }
        .drag-handle:hover {
            color: var(--dakota-gold);
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .drop-zone {
            min-height: 40px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            margin: 0.5rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        .drop-zone.drag-over {
            border-color: var(--dakota-gold);
            background: rgba(196, 164, 105, 0.1);
            color: var(--dakota-gold);
        }
        .wochentag-section {
            padding: 0.5rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            transition: all 0.2s ease;
        }
        .wochentag-section.drag-over {
            background: rgba(196, 164, 105, 0.15);
            box-shadow: inset 0 0 0 2px var(--dakota-gold);
        }

        /* ===== CALCULATION RESULT ===== */
        .calc-result {
            background: linear-gradient(135deg, var(--dakota-gold) 0%, #c89654 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            margin-top: 2rem;
        }

        .calc-result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .calc-result-item {
            text-align: center;
        }

        .calc-result-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .calc-result-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* ===== REZEPT DETAIL MODAL ===== */
        .rezept-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            overflow-y: auto;
            padding: 2rem;
        }

        .rezept-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rezept-modal-content {
            background: white;
            border-radius: 12px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .rezept-modal-header {
            background: linear-gradient(135deg, var(--dakota-dark) 0%, #1a1d20 100%);
            color: var(--dakota-gold);
            padding: 2rem;
            border-radius: 12px 12px 0 0;
            position: relative;
        }

        .rezept-modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rezept-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .rezept-modal-title {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            font-family: 'Playfair Display', serif;
        }

        .rezept-modal-meta {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            margin-top: 1rem;
            font-size: 0.95rem;
            opacity: 0.95;
        }

        .rezept-modal-meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .rezept-modal-body {
            padding: 2rem;
        }

        .rezept-modal-section {
            margin-bottom: 2rem;
        }

        .rezept-modal-section-title {
            font-size: 1.3rem;
            margin-bottom: 1rem;
            color: var(--dakota-dark);
            border-bottom: 2px solid var(--dakota-gold);
            padding-bottom: 0.5rem;
        }

        .rezept-zutaten-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.75rem;
        }

        .rezept-zutat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--dakota-light);
            border-radius: 6px;
            border-left: 3px solid var(--dakota-gold);
        }

        .rezept-zutat-name {
            font-weight: 600;
            color: var(--dakota-dark);
        }

        .rezept-zutat-menge {
            color: #666;
            white-space: nowrap;
        }

        .rezept-zubereitung-list {
            counter-reset: step-counter;
            list-style: none;
        }

        .rezept-zubereitung-list li {
            counter-increment: step-counter;
            position: relative;
            padding-left: 3rem;
            margin-bottom: 1.25rem;
            line-height: 1.6;
        }

        .rezept-zubereitung-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            width: 2rem;
            height: 2rem;
            background: var(--dakota-gold);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .rezept-cost-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            background: var(--dakota-light);
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        .rezept-cost-item {
            text-align: center;
        }

        .rezept-cost-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--dakota-dark);
        }

        .rezept-cost-value.good {
            color: var(--success);
        }

        .rezept-cost-value.warning {
            color: var(--warning);
        }

        .rezept-cost-value.danger {
            color: var(--danger);
        }

        .rezept-cost-label {
            font-size: 0.85rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }

        .rezept-bemerkung {
            background: #fff3cd;
            border-left: 4px solid var(--warning);
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
        }

        .rezept-quelle {
            font-size: 0.85rem;
            opacity: 0.7;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #ddd;
        }

        .rezept-quelle a {
            color: var(--dakota-gold);
            text-decoration: none;
        }

        .rezept-quelle a:hover {
            text-decoration: underline;
        }

        /* ===== PRINT STYLES F√úR DIENSTPLAN PDF-EXPORT ===== */
        @media print {
            /* Alles au√üer Dienstplan ausblenden */
            body * {
                visibility: hidden;
            }

            .print-container,
            .print-container * {
                visibility: visible;
            }

            .print-container {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
            }

            /* Header und Navigation ausblenden */
            .header, .nav-tabs, .diensttypen-palette, .card-header button,
            .modal, .btn, footer {
                display: none !important;
            }

            /* Dienstplan-Kalender optimieren */
            .dienstplan-kalender {
                min-width: auto !important;
                font-size: 10px;
            }

            .dienstplan-cell {
                padding: 2px !important;
                min-height: 24px !important;
            }

            .schicht-badge {
                font-size: 8px !important;
                padding: 2px 4px !important;
                min-width: 20px !important;
                min-height: 16px !important;
            }

            .fill-handle {
                display: none !important;
            }

            /* Print Header */
            .print-header {
                text-align: center;
                margin-bottom: 20px;
                padding: 10px;
                border-bottom: 2px solid #333;
            }

            .print-header h1 {
                margin: 0;
                font-size: 18px;
            }

            .print-header p {
                margin: 5px 0 0;
                font-size: 12px;
                color: #666;
            }

            /* Legende f√ºr Print */
            .print-legende {
                margin-top: 20px;
                padding: 10px;
                border-top: 1px solid #ddd;
            }

            .print-legende-title {
                font-weight: bold;
                margin-bottom: 10px;
            }

            .print-legende-items {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            }

            .print-legende-item {
                display: flex;
                align-items: center;
                gap: 5px;
                font-size: 10px;
            }

            @page {
                size: landscape;
                margin: 10mm;
            }
        }
    </style>
</head>

<body>
    <!-- HEADER -->
    <header class="header">
        <div class="header-content">
            <div class="logo">DAKOTA KALKULATIONS-TOOL</div>
            <!-- Global Search -->
            <div class="global-search-container">
                <span class="global-search-icon">üîç</span>
                <input type="text"
                       class="global-search-input"
                       id="globalSearchInput"
                       placeholder="Suchen... (Ctrl+K)"
                       autocomplete="off">
                <span class="search-shortcut">Ctrl+K</span>
                <div class="global-search-results" id="globalSearchResults"></div>
            </div>

            <div class="header-stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalLebensmittel">0</div>
                    <div class="stat-label">Lebensmittel</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalRezepte">0</div>
                    <div class="stat-label">Rezepte</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgFoodCost">0%</div>
                    <div class="stat-label">√ò Food Cost</div>
                </div>
            </div>
        </div>
    </header>

    <!-- NAVIGATION TABS -->
    <nav class="nav-tabs">
        <div class="tabs-container">
            <button class="tab-button active" onclick="switchTab('lebensmittel')">
                <span class="tab-icon">ü•ï</span> Lebensmittel-Datenbank
            </button>
            <button class="tab-button" onclick="switchTab('rezepte')">
                <span class="tab-icon">üìñ</span> Rezept-Datenbank
            </button>
            <button class="tab-button" onclick="switchTab('kalkulation')">
                <span class="tab-icon">üí∞</span> Kalkulation
            </button>
            <button class="tab-button" onclick="switchTab('einkaufsliste')">
                <span class="tab-icon">üõí</span> Einkaufsliste
            </button>
            <button class="tab-button" onclick="switchTab('menuekarten')">
                <span class="tab-icon">üçΩÔ∏è</span> Men√ºkarten
            </button>
            <button class="tab-button" onclick="switchTab('einstellungen')">
                <span class="tab-icon">‚öôÔ∏è</span> Einstellungen
            </button>
            <button class="tab-button" onclick="switchTab('dienstplan')">
                <span class="tab-icon">üìÖ</span> Dienstplan
            </button>
        </div>
    </nav>

    <!-- MAIN CONTAINER -->
    <div class="container">

        <!-- TAB 1: LEBENSMITTEL-DATENBANK -->
        <div id="tab-lebensmittel" class="tab-content active">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span>ü•ï</span> Lebensmittel-Stammdaten
                    </h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-primary" onclick="openLebensmittelModal()">
                            ‚ûï Neues Lebensmittel
                        </button>
                    </div>
                </div>

                <!-- IMPORT/EXPORT BEREICH -->
                <div class="card" style="margin-top: 1rem; background: #f8f9fa;">
                    <div class="card-header" style="background: #e9ecef;">
                        <h3 style="margin: 0; font-size: 1rem; color: #495057;">
                            <span>üì§</span> Import/Export Daten
                        </h3>
                    </div>
                    <div style="padding: 1rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="btn btn-secondary"
                                style="display: block; text-align: center; margin: 0; cursor: pointer;">
                                üì• Lebensmittel importieren (.json)
                                <input type="file" id="importLebensmittelFile" accept=".json" style="display: none;"
                                    onchange="importLebensmittelJSON(event)">
                            </label>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <button class="btn btn-primary"
                                style="display: block; width: 100%; text-align: center; margin: 0;"
                                onclick="exportLebensmittelJSON()">
                                üì§ Lebensmittel exportieren (.json)
                            </button>
                        </div>
                    </div>
                </div>

                <div class="search-bar">
                    <span class="search-icon">üîç</span>
                    <input type="text" class="search-input" id="searchLebensmittel"
                        placeholder="Lebensmittel suchen... (Name, Kategorie, Lieferant)"
                        onkeyup="searchLebensmittel()">
                </div>

                <div class="form-group">
                    <label class="form-label">Filter nach Kategorie:</label>
                    <select class="form-select" id="filterKategorie" onchange="filterLebensmittel()">
                        <option value="">Alle Kategorien</option>
                        <option value="Fleisch">Fleisch</option>
                        <option value="Fisch & Meeresfr√ºchte">Fisch & Meeresfr√ºchte</option>
                        <option value="K√§se">K√§se</option>
                        <option value="Milchprodukte">Milchprodukte</option>
                        <option value="Gem√ºse">Gem√ºse</option>
                        <option value="Pilze">Pilze</option>
                        <option value="Teigwaren & Getreide">Teigwaren & Getreide</option>
                        <option value="Gew√ºrze & Kr√§uter">Gew√ºrze & Kr√§uter</option>
                        <option value="√ñle & Essig">√ñle & Essig</option>
                        <option value="Fr√ºchte">Fr√ºchte</option>
                        <option value="Premium-Zutaten">Premium-Zutaten</option>
                        <option value="Alkohol (Kochen)">Alkohol (Kochen)</option>
                        <option value="Sonstige">Sonstige</option>
                    </select>
                </div>

                <!-- SAISON-FILTER -->
                <div class="saison-filter-container" style="margin-top: 1rem;">
                    <span style="font-weight: 600; color: #666; margin-right: 0.5rem;">üåø Saison:</span>
                    <button class="saison-filter-btn active" onclick="filterBySaison('alle')">Alle</button>
                    <button class="saison-filter-btn" onclick="filterBySaison('in-saison')">Jetzt in Saison</button>
                    <button class="saison-filter-btn" onclick="filterBySaison('bald-saison')">Bald in Saison</button>
                    <button class="saison-filter-btn" onclick="filterBySaison('off-saison')">Nicht in Saison</button>
                </div>

                <div id="lebensmittelTable"></div>
            </div>
        </div>

        <!-- TAB 2: REZEPT-DATENBANK -->
        <div id="tab-rezepte" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span>üìñ</span> Rezept-Verwaltung
                    </h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-primary" onclick="openRezeptModal()">
                            ‚ûï Neues Rezept
                        </button>
                    </div>
                </div>

                <!-- IMPORT/EXPORT BEREICH -->
                <div class="card" style="margin-top: 1rem; background: #f8f9fa;">
                    <div class="card-header" style="background: #e9ecef;">
                        <h3 style="margin: 0; font-size: 1rem; color: #495057;">
                            <span>üì§</span> Import/Export Daten
                        </h3>
                    </div>
                    <div style="padding: 1rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="btn btn-secondary"
                                style="display: block; text-align: center; margin: 0; cursor: pointer;">
                                üì• Rezepte importieren (.json)
                                <input type="file" id="importRezepteFile" accept=".json" style="display: none;"
                                    onchange="importRezepteJSON(event)">
                            </label>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <button class="btn btn-primary"
                                style="display: block; width: 100%; text-align: center; margin: 0;"
                                onclick="exportRezepteJSON()">
                                üì§ Rezepte exportieren (.json)
                            </button>
                        </div>
                    </div>
                </div>

                <div class="search-bar">
                    <span class="search-icon">üîç</span>
                    <input type="text" class="search-input" id="searchRezepte"
                        placeholder="Rezepte suchen... (Name, Kategorie)" onkeyup="searchRezepte()">
                </div>

                <div class="form-group">
                    <label class="form-label">Filter nach Kategorie:</label>
                    <select class="form-select" id="filterRezeptKategorie" onchange="filterRezepte()">
                        <option value="">Alle Kategorien</option>
                        <option value="Vorspeise">Vorspeise</option>
                        <option value="Suppe">Suppe</option>
                        <option value="Hauptgericht Fleisch">Hauptgericht Fleisch</option>
                        <option value="Hauptgericht Vegetarisch">Hauptgericht Vegetarisch</option>
                        <option value="Dessert">Dessert</option>
                        <option value="Beilage">Beilage</option>
                    </select>
                </div>

                <div id="rezepteTable"></div>
            </div>
        </div>

        <!-- TAB 3: KALKULATION -->
        <div id="tab-kalkulation" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span>üí∞</span> Rezept-Kalkulation
                    </h2>
                </div>

                <div class="form-group">
                    <label class="form-label">Rezept ausw√§hlen:</label>
                    <select class="form-select" id="calcRezeptSelect" onchange="loadRezeptForCalculation()">
                        <option value="">-- Rezept w√§hlen --</option>
                    </select>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Anzahl Personen:</label>
                        <input type="number" class="form-input" id="calcPersonen" value="1" min="1" max="1000"
                            onchange="recalculate()">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Verkaufspreis (CHF/Person):</label>
                        <input type="number" class="form-input" id="calcVerkaufspreis" step="0.01"
                            onchange="recalculate()">
                    </div>
                </div>

                <div id="calcDetails"></div>
                <div id="calcResult"></div>

                <div style="margin-top: 2rem; display: flex; gap: 1rem;">
                    <button class="btn btn-primary" onclick="exportCalcPDF()">
                        üìÑ Als PDF exportieren
                    </button>
                    <button class="btn btn-secondary" onclick="saveCalculation()">
                        üíæ Kalkulation speichern
                    </button>
                </div>
            </div>
        </div>

        <!-- TAB 4: EINKAUFSLISTE -->
        <div id="tab-einkaufsliste" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span>üõí</span> Einkaufsliste Generator
                    </h2>
                    <button class="btn btn-primary" onclick="generateEinkaufsliste()">
                        ‚ú® Einkaufsliste generieren
                    </button>
                </div>

                <div class="form-group">
                    <label class="form-label">Rezepte ausw√§hlen (mehrere m√∂glich):</label>
                    <div id="einkaufslisteRezepte"
                        style="max-height: 300px; overflow-y: auto; border: 2px solid #ddd; border-radius: 8px; padding: 1rem;">
                        <!-- Wird dynamisch gef√ºllt -->
                    </div>
                </div>

                <div id="einkaufslisteResult"></div>

                <div style="margin-top: 2rem; display: flex; gap: 1rem;">
                    <button class="btn btn-primary" onclick="exportEinkaufslistePDF()">
                        üìÑ Als PDF exportieren
                    </button>
                    <button class="btn btn-secondary" onclick="printEinkaufsliste()">
                        üñ®Ô∏è Drucken
                    </button>
                </div>
            </div>
        </div>

        <!-- TAB 5: MEN√úKARTEN -->
        <div id="tab-menuekarten" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span>üçΩÔ∏è</span> Men√ºkarten-Verwaltung
                    </h2>
                    <button class="btn btn-primary" onclick="openMenuekartenModal()">
                        ‚ûï Neue Men√ºkarte erstellen
                    </button>
                </div>

                <!-- IMPORT/EXPORT BEREICH -->
                <div class="card" style="margin-top: 1rem; background: #f8f9fa;">
                    <div class="card-header" style="background: #e9ecef;">
                        <h3 style="margin: 0; font-size: 1rem; color: #495057;">
                            <span>üì§</span> Import/Export Daten
                        </h3>
                    </div>
                    <div style="padding: 1rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="btn btn-secondary"
                                style="display: block; text-align: center; margin: 0; cursor: pointer;">
                                üì• Men√ºkarten importieren (.json)
                                <input type="file" id="importMenuekartenFile" accept=".json" style="display: none;"
                                    onchange="importMenuekartenJSON(event)">
                            </label>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <button class="btn btn-primary"
                                style="display: block; width: 100%; text-align: center; margin: 0;"
                                onclick="exportMenuekartenJSON()">
                                üì§ Men√ºkarten exportieren (.json)
                            </button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Filter nach Typ:</label>
                    <select class="form-select" id="filterMenuekartenTyp" onchange="filterMenuekarten()"
                        style="max-width: 400px;">
                        <option value="">Alle Typen</option>
                        <option value="abendkarte">üåô Aktuelle √† la carte Karte (Abendkarte)</option>
                        <option value="mittagsmenu">‚òÄÔ∏è Mittagsmen√º (Mittagskarte)</option>
                    </select>
                </div>

                <div id="menuekartenTable"></div>
            </div>
        </div>

        <!-- TAB 6: EINSTELLUNGEN -->
        <div id="tab-einstellungen" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span>‚öôÔ∏è</span> Einstellungen
                    </h2>
                </div>

                <!-- API-KEY VERWALTUNG -->
                <div class="settings-section">
                    <h3 class="settings-section-title">
                        <span>üîë</span> OpenAI API-Key
                    </h3>
                    <p style="color: #666; margin-bottom: 1rem; font-size: 0.9rem;">
                        F√ºr die automatische Erkennung von Lieferscheinen wird ein OpenAI API-Key ben√∂tigt.
                        Der Key wird sicher in deiner lokalen Datenbank gespeichert.
                    </p>
                    <div class="api-key-container">
                        <div class="api-key-input-wrapper">
                            <input type="password" class="api-key-input" id="openaiApiKey"
                                placeholder="sk-..." autocomplete="off">
                            <button type="button" class="api-key-toggle" onclick="toggleApiKeyVisibility()">üëÅÔ∏è</button>
                        </div>
                        <button class="btn btn-primary" onclick="saveApiKey()">
                            üíæ Speichern
                        </button>
                        <button class="btn btn-secondary" onclick="testApiKey()">
                            üß™ Testen
                        </button>
                    </div>
                    <div class="api-key-status" id="apiKeyStatus"></div>
                </div>

                <!-- LIEFERSCHEIN SCANNER -->
                <div class="settings-section">
                    <h3 class="settings-section-title">
                        <span>üì∏</span> Lieferschein-Scanner
                    </h3>
                    <p style="color: #666; margin-bottom: 1rem; font-size: 0.9rem;">
                        Fotografiere oder lade einen Lieferschein hoch. GPT-4 Vision erkennt automatisch
                        die Produkte und Preise und gleicht sie mit deiner Datenbank ab.
                    </p>

                    <div class="upload-zone" id="uploadZone" onclick="document.getElementById('lieferscheinInput').click()">
                        <div class="upload-zone-icon">üì∏</div>
                        <div class="upload-zone-text">Lieferschein hier ablegen oder klicken</div>
                        <div class="upload-zone-hint">Unterst√ºtzt: JPG, PNG, PDF (max. 20MB)</div>
                        <input type="file" id="lieferscheinInput" accept="image/*,.pdf"
                            style="display: none;" onchange="handleLieferscheinUpload(event)">
                    </div>

                    <div class="upload-preview" id="uploadPreview">
                        <div class="preview-image-container">
                            <img id="previewImage" class="preview-image" src="" alt="Vorschau">
                        </div>
                        <div style="text-align: center;">
                            <button class="btn btn-primary" onclick="analyzeLieferschein()">
                                üîç Lieferschein analysieren
                            </button>
                            <button class="btn btn-secondary" onclick="clearLieferscheinUpload()">
                                ‚ùå Abbrechen
                            </button>
                        </div>
                    </div>

                    <div id="scannerLoading" class="scanner-loading" style="display: none;">
                        <div class="scanner-loading-spinner"></div>
                        <div>GPT-4 Vision analysiert den Lieferschein...</div>
                    </div>

                    <div id="scannerResults" class="scanner-results" style="display: none;">
                        <h4 class="scanner-results-title">
                            <span>‚úÖ</span> <span id="resultsTitle">Erkannte Produkte</span>
                        </h4>
                        <ul class="scanner-product-list" id="scannerProductList"></ul>
                        <div style="margin-top: 1.5rem; display: flex; gap: 0.75rem; justify-content: center;">
                            <button class="btn btn-primary" onclick="importScannerResults()">
                                ‚úÖ Alle importieren
                            </button>
                            <button class="btn btn-secondary" onclick="clearScannerResults()">
                                üóëÔ∏è Verwerfen
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB 7: DIENSTPLAN -->
        <div id="tab-dienstplan" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span>üìÖ</span> Dienstplan
                    </h2>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button class="btn btn-secondary" onclick="prevMonth()">‚óÄ</button>
                        <select id="dienstplanMonat" class="form-select" style="min-width: 150px;" onchange="loadDienstplan()">
                        </select>
                        <select id="dienstplanJahr" class="form-select" style="min-width: 100px;" onchange="loadDienstplan()">
                        </select>
                        <button class="btn btn-secondary" onclick="nextMonth()">‚ñ∂</button>
                        <button class="btn btn-primary" onclick="openMitarbeiterModal()" style="margin-left: 1rem;">
                            üë• Mitarbeiter
                        </button>
                        <button class="btn btn-success" onclick="exportDienstplanPDF()">
                            üìÑ PDF Export
                        </button>
                    </div>
                </div>

                <!-- DIENSTPLAN LAYOUT: Palette + Kalender -->
                <div class="dienstplan-layout">
                    <!-- Linke Spalte: Drag & Drop Palette -->
                    <div class="diensttypen-palette">
                        <h4>üìã Diensttypen</h4>
                        <div class="palette-items" id="diensttypenPalette">
                            <!-- Wird dynamisch gef√ºllt -->
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="openDiensttypenModal()" style="width: 100%;">
                            ‚öôÔ∏è Verwalten
                        </button>
                    </div>

                    <!-- Rechte Spalte: Kalender -->
                    <div class="dienstplan-container">
                        <div class="dienstplan-kalender" id="dienstplanKalender">
                            <!-- Wird dynamisch gef√ºllt -->
                        </div>
                    </div>
                </div>

                <!-- LEGENDE (dynamisch aus Diensttypen) -->
                <div class="dienstplan-legende">
                    <h4 style="margin-bottom: 0.75rem;">Legende</h4>
                    <div class="legende-grid" id="dienstplanLegende">
                        <!-- Wird dynamisch gef√ºllt -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL: DIENSTTYPEN VERWALTEN -->
    <div id="diensttypenModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>Diensttypen verwalten</h2>
                <button class="modal-close" onclick="closeDiensttypenModal()">√ó</button>
            </div>
            <div style="margin-bottom: 1rem;">
                <button class="btn btn-primary" onclick="addNewDiensttyp()">‚ûï Neuer Diensttyp</button>
            </div>
            <div id="diensttypenListe" class="diensttypen-liste">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
        </div>
    </div>

    <!-- MODAL: DIENSTTYP BEARBEITEN -->
    <div id="diensttypEditModal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2 id="diensttypEditTitle">Diensttyp bearbeiten</h2>
                <button class="modal-close" onclick="closeDiensttypEditModal()">√ó</button>
            </div>
            <form id="diensttypForm" onsubmit="saveDiensttyp(event)">
                <input type="hidden" id="dt_id">
                <div class="form-group">
                    <label class="form-label">Code (1-3 Zeichen) *</label>
                    <input type="text" class="form-input" id="dt_code" maxlength="3" required style="text-transform: uppercase; width: 80px;">
                </div>
                <div class="form-group">
                    <label class="form-label">Name *</label>
                    <input type="text" class="form-input" id="dt_name" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Arbeitszeit 1 (optional)</label>
                    <input type="text" class="form-input" id="dt_zeit" placeholder="z.B. 6:00-14:30">
                </div>
                <div class="form-group">
                    <label class="form-label">Arbeitszeit 2 (bei Teildienst)</label>
                    <input type="text" class="form-input" id="dt_zeit2" placeholder="z.B. 18:00-22:00">
                </div>
                <div class="form-group">
                    <label class="form-label">Farbe *</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="dt_farbe" value="#3498db">
                        <span id="dt_farbe_hex">#3498db</span>
                    </div>
                </div>
                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button type="submit" class="btn btn-success">üíæ Speichern</button>
                    <button type="button" class="btn btn-secondary" onclick="closeDiensttypEditModal()">Abbrechen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- MODAL: MITARBEITER VERWALTEN -->
    <div id="mitarbeiterModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>Mitarbeiter verwalten</h2>
                <button class="modal-close" onclick="closeMitarbeiterModal()">√ó</button>
            </div>
            <div style="margin-bottom: 1rem;">
                <button class="btn btn-primary" onclick="addNewMitarbeiter()">‚ûï Neuer Mitarbeiter</button>
            </div>
            <div id="mitarbeiterListe" class="mitarbeiter-liste">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
        </div>
    </div>

    <!-- MODAL: MITARBEITER BEARBEITEN -->
    <div id="mitarbeiterEditModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="mitarbeiterEditTitle">Mitarbeiter bearbeiten</h2>
                <button class="modal-close" onclick="closeMitarbeiterEditModal()">√ó</button>
            </div>
            <form id="mitarbeiterForm" onsubmit="saveMitarbeiter(event)">
                <input type="hidden" id="ma_id">
                <div class="form-group">
                    <label class="form-label">Name *</label>
                    <input type="text" class="form-input" id="ma_name" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Rolle</label>
                    <select class="form-select" id="ma_rolle">
                        <option value="Koch">Koch</option>
                        <option value="CHEF">K√ºchenchef</option>
                        <option value="Souschef">Souschef</option>
                        <option value="Commis">Commis</option>
                        <option value="Aushilfe">Aushilfe</option>
                        <option value="Praktikant">Praktikant</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Arbeitspensum (%)</label>
                    <input type="number" class="form-input" id="ma_prozent" value="100" min="0" max="100">
                </div>
                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button type="submit" class="btn btn-success">üíæ Speichern</button>
                    <button type="button" class="btn btn-secondary" onclick="closeMitarbeiterEditModal()">Abbrechen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- MODAL: SCHICHT AUSW√ÑHLEN -->
    <div id="schichtModal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2 id="schichtModalTitle">Schicht w√§hlen</h2>
                <button class="modal-close" onclick="closeSchichtModal()">√ó</button>
            </div>
            <input type="hidden" id="schicht_mitarbeiter_id">
            <input type="hidden" id="schicht_datum">
            <div class="schicht-auswahl" id="schichtAuswahlContainer">
                <!-- Dynamisch gef√ºllt -->
            </div>
        </div>
    </div>

    <!-- MODAL: LEBENSMITTEL BEARBEITEN/ERSTELLEN -->
    <div id="lebensmittelModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="lebensmittelModalTitle">Neues Lebensmittel</h2>
                <button class="modal-close" onclick="closeLebensmittelModal()">√ó</button>
            </div>

            <form id="lebensmittelForm" onsubmit="saveLebensmittel(event)">
                <input type="hidden" id="lm_id">

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Name *</label>
                        <input type="text" class="form-input" id="lm_name" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Kategorie *</label>
                        <select class="form-select" id="lm_kategorie" required>
                            <option value="">-- W√§hlen --</option>
                            <option value="Fleisch">Fleisch</option>
                            <option value="Fisch & Meeresfr√ºchte">Fisch & Meeresfr√ºchte</option>
                            <option value="K√§se">K√§se</option>
                            <option value="Milchprodukte">Milchprodukte</option>
                            <option value="Gem√ºse">Gem√ºse</option>
                            <option value="Pilze">Pilze</option>
                            <option value="Teigwaren & Getreide">Teigwaren & Getreide</option>
                            <option value="Gew√ºrze & Kr√§uter">Gew√ºrze & Kr√§uter</option>
                            <option value="√ñle & Essig">√ñle & Essig</option>
                            <option value="Fr√ºchte">Fr√ºchte</option>
                            <option value="Premium-Zutaten">Premium-Zutaten</option>
                            <option value="Alkohol (Kochen)">Alkohol (Kochen)</option>
                            <option value="Sonstige">Sonstige</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Preis pro Einheit (CHF) *</label>
                        <input type="number" class="form-input" id="lm_preis" step="0.01" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Einheit *</label>
                        <select class="form-select" id="lm_einheit" required>
                            <option value="kg">Kilogramm (kg)</option>
                            <option value="L">Liter (L)</option>
                            <option value="Stk">St√ºck (Stk)</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">R√ºstverlust (%)</label>
                        <input type="number" class="form-input" id="lm_ruestverlust" value="0" min="0" max="100">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Garverlust (%)</label>
                        <input type="number" class="form-input" id="lm_garverlust" value="0" min="0" max="100">
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Lieferant</label>
                    <input type="text" class="form-input" id="lm_lieferant">
                </div>

                <div class="form-group">
                    <label class="form-label">üåø Saison (Monate)</label>
                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.5rem;">
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_jan" value="1"> Jan</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_feb" value="2"> Feb</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_mar" value="3"> M√§r</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_apr" value="4"> Apr</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_mai" value="5"> Mai</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_jun" value="6"> Jun</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_jul" value="7"> Jul</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_aug" value="8"> Aug</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_sep" value="9"> Sep</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_okt" value="10"> Okt</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_nov" value="11"> Nov</label>
                        <label class="saison-checkbox"><input type="checkbox" id="lm_saison_dez" value="12"> Dez</label>
                    </div>
                    <small style="color: #888; margin-top: 0.25rem; display: block;">W√§hle die Monate, in denen das Produkt Saison hat (leer = ganzj√§hrig verf√ºgbar)</small>
                </div>

                <div class="form-group">
                    <label class="form-label">Bemerkungen</label>
                    <textarea class="form-textarea" id="lm_bemerkungen" rows="3"></textarea>
                </div>

                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button type="submit" class="btn btn-success">üíæ Speichern</button>
                    <button type="button" class="btn btn-secondary"
                        onclick="closeLebensmittelModal()">Abbrechen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- MODAL: REZEPT BEARBEITEN/ERSTELLEN -->
    <div id="rezeptModal" class="modal">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h2 id="rezeptModalTitle">Neues Rezept</h2>
                <button class="modal-close" onclick="closeRezeptModal()">√ó</button>
            </div>

            <form id="rezeptForm" onsubmit="saveRezept(event)">
                <input type="hidden" id="rz_id">

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Rezeptname *</label>
                        <input type="text" class="form-input" id="rz_name" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Kategorie *</label>
                        <select class="form-select" id="rz_kategorie" required>
                            <option value="">-- W√§hlen --</option>
                            <option value="Vorspeise">Vorspeise</option>
                            <option value="Suppe">Suppe</option>
                            <option value="Hauptgang">Hauptgang</option>
                            <option value="Dessert">Dessert</option>
                            <option value="Amuse-Bouche">Amuse-Bouche</option>
                            <option value="Zwischengang">Zwischengang</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Portionen *</label>
                        <input type="number" class="form-input" id="rz_portionen" value="1" min="1" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Verkaufspreis (CHF) *</label>
                        <input type="number" class="form-input" id="rz_verkaufspreis" step="0.01" required>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Beschreibung</label>
                    <textarea class="form-textarea" id="rz_beschreibung" rows="2"></textarea>
                </div>

                <hr style="margin: 2rem 0; border: none; border-top: 2px solid var(--dakota-gold);">

                <h3 style="margin-bottom: 1rem;">Zutaten</h3>
                <div id="rzZutatenContainer">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>

                <button type="button" class="btn btn-primary btn-sm" onclick="addRezeptZutat()"
                    style="margin-top: 1rem;">
                    ‚ûï Zutat hinzuf√ºgen
                </button>

                <hr style="margin: 2rem 0; border: none; border-top: 2px solid var(--dakota-gold);">

                <h3 style="margin-bottom: 1rem;">Zubereitung</h3>
                <div id="rzZubereitungContainer">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>
                <button type="button" class="btn btn-primary btn-sm" onclick="addZubereitungsSchritt()"
                    style="margin-top: 1rem;">
                    ‚ûï Zubereitungsschritt hinzuf√ºgen
                </button>

                <hr style="margin: 2rem 0; border: none; border-top: 2px solid var(--dakota-gold);">

                <h3 style="margin-bottom: 1rem;">Allergene & Zusatzinformationen</h3>

                <div class="form-group">
                    <label class="form-label">Allergene (kommagetrennt)</label>
                    <input type="text" class="form-input" id="rz_allergene"
                        placeholder="z.B. Gluten, Milch, Eier, N√ºsse">
                    <small style="color: #666; font-size: 0.85rem; display: block; margin-top: 0.25rem;">
                        Verf√ºgbar: Gluten, Milch, Eier, Fisch, N√ºsse, Erdn√ºsse, Soja, Sellerie, Senf, Sesam, Sulfite,
                        Lupinen, Weichtiere, Krebstiere
                    </small>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Zubereitungszeit</label>
                        <input type="text" class="form-input" id="rz_zubereitungszeit" placeholder="z.B. 45 Minuten">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Schwierigkeit</label>
                        <select class="form-select" id="rz_schwierigkeit">
                            <option value="">-- Nicht angegeben --</option>
                            <option value="Einfach">Einfach</option>
                            <option value="Mittel">Mittel</option>
                            <option value="Schwer">Schwer</option>
                            <option value="Profi">Profi</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Quelle</label>
                    <input type="text" class="form-input" id="rz_quelle"
                        placeholder="z.B. Betty Bossi, Eigenes Rezept, https://...">
                </div>

                <div class="form-group">
                    <label class="form-label">Bemerkung / Tipp</label>
                    <textarea class="form-textarea" id="rz_bemerkung" rows="2"
                        placeholder="Tipp f√ºr die Zubereitung oder Anrichtung..."></textarea>
                </div>

                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button type="submit" class="btn btn-success">üíæ Rezept speichern</button>
                    <button type="button" class="btn btn-secondary" onclick="closeRezeptModal()">Abbrechen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- MODAL: MEN√úKARTE BEARBEITEN/ERSTELLEN -->
    <div id="menuekarteModal" class="modal">
        <div class="modal-content" style="max-width: 1200px;">
            <div class="modal-header">
                <h2 id="menuekarteModalTitle">Neue Men√ºkarte</h2>
                <button class="modal-close" onclick="closeMenuekarteModal()">√ó</button>
            </div>

            <form id="menuekarteForm" onsubmit="saveMenuekarte(event)">
                <input type="hidden" id="mk_id">

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Kartenname *</label>
                        <input type="text" class="form-input" id="mk_name" placeholder="z.B. Abendkarte Dezember 2025"
                            required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Typ *</label>
                        <select class="form-select" id="mk_typ" required
                            onchange="renderGerichteListe(); toggleWochentagVisibility()">
                            <option value="">-- W√§hlen --</option>
                            <option value="abendkarte">üåô Aktuelle √† la carte Karte (Abendkarte)</option>
                            <option value="mittagsmenu">‚òÄÔ∏è Mittagsmen√º (Mittagskarte)</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">
                        <input type="checkbox" id="mk_aktiv">
                        Diese Karte ist aktuell aktiv
                    </label>
                </div>

                <div class="form-group">
                    <label class="form-label">Bemerkungen</label>
                    <textarea class="form-textarea" id="mk_bemerkungen" rows="2"
                        placeholder="z.B. Saison: Winter 2025, G√ºltig bis..."></textarea>
                </div>

                <hr style="margin: 2rem 0; border: none; border-top: 2px solid var(--dakota-gold);">

                <h3 style="margin-bottom: 1rem;">Gerichte auf der Karte</h3>

                <!-- Rezept-Auswahl -->
                <div style="margin-bottom: 2rem;">
                    <label class="form-label">Rezept hinzuf√ºgen:</label>
                    <div class="form-row">
                        <div class="form-group" style="flex: 2;">
                            <select class="form-select" id="mk_rezept_select">
                                <option value="">-- Rezept ausw√§hlen --</option>
                                <!-- Wird dynamisch gef√ºllt -->
                            </select>
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <select class="form-select" id="mk_rezept_kategorie">
                                <option value="Vorspeise">Vorspeise</option>
                                <option value="Suppe">Suppe</option>
                                <option value="Hauptgang">Hauptgang</option>
                                <option value="Dessert">Dessert</option>
                                <option value="Beilage">Beilage</option>
                            </select>
                        </div>
                        <div class="form-group" style="flex: 1;" id="mk_wochentag_container">
                            <select class="form-select" id="mk_rezept_wochentag">
                                <option value="">Kein Wochentag</option>
                                <option value="Montag">Montag</option>
                                <option value="Dienstag">Dienstag</option>
                                <option value="Mittwoch">Mittwoch</option>
                                <option value="Donnerstag">Donnerstag</option>
                                <option value="Freitag">Freitag</option>
                                <option value="Samstag">Samstag</option>
                                <option value="Sonntag">Sonntag</option>
                            </select>
                        </div>
                        <button type="button" class="btn btn-success" onclick="addRezeptToKarte()">
                            ‚ûï Hinzuf√ºgen
                        </button>
                    </div>
                </div>

                <!-- Liste der hinzugef√ºgten Gerichte -->
                <div id="mk_gerichte_container">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>

                <hr style="margin: 2rem 0; border: none; border-top: 2px solid var(--dakota-gold);">

                <!-- Kalkulation Preview -->
                <div id="mk_kalkulation_preview"
                    style="background: var(--dakota-light); padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Karten-Kalkulation</h3>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--dakota-dark);"
                                id="mk_anzahl_gerichte">0</div>
                            <div style="font-size: 0.85rem; opacity: 0.7;">Gerichte</div>
                        </div>
                        <div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--dakota-dark);"
                                id="mk_avg_foodcost">0%</div>
                            <div style="font-size: 0.85rem; opacity: 0.7;">√ò Food Cost</div>
                        </div>
                        <div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--dakota-dark);"
                                id="mk_avg_preis">0.-</div>
                            <div style="font-size: 0.85rem; opacity: 0.7;">√ò Verkaufspreis</div>
                        </div>
                        <div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--dakota-dark);"
                                id="mk_total_wareneinsatz">0.-</div>
                            <div style="font-size: 0.85rem; opacity: 0.7;">Total Wareneinsatz</div>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button type="submit" class="btn btn-success">üíæ Men√ºkarte speichern</button>
                    <button type="button" class="btn btn-secondary" onclick="closeMenuekarteModal()">Abbrechen</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ===== GLOBAL STATE =====
        let db;
        let lebensmittelData = [];
        let rezepteData = [];
        let menuekartenData = [];
        let currentMenuekarteGerichte = [];
        let currentEditId = null;

        // ===== INDEXEDDB INIT =====
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('DakotaKalkulationDB', 3);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;

                    // Lebensmittel Store
                    if (!db.objectStoreNames.contains('lebensmittel')) {
                        const lmStore = db.createObjectStore('lebensmittel', { keyPath: 'id', autoIncrement: true });
                        lmStore.createIndex('name', 'name', { unique: false });
                        lmStore.createIndex('kategorie', 'kategorie', { unique: false });
                    }

                    // Rezepte Store
                    if (!db.objectStoreNames.contains('rezepte')) {
                        const rzStore = db.createObjectStore('rezepte', { keyPath: 'id', autoIncrement: true });
                        rzStore.createIndex('name', 'name', { unique: false });
                        rzStore.createIndex('kategorie', 'kategorie', { unique: false });
                    }

                    // Men√ºkarten Store (Version 2)
                    if (!db.objectStoreNames.contains('menuekarten')) {
                        const mkStore = db.createObjectStore('menuekarten', { keyPath: 'id', autoIncrement: true });
                        mkStore.createIndex('typ', 'typ', { unique: false });
                        mkStore.createIndex('name', 'name', { unique: false });
                        mkStore.createIndex('aktiv', 'aktiv', { unique: false });
                    }

                    // Settings Store (Version 3) - f√ºr API-Keys etc.
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                        console.log('‚úÖ Settings Store erstellt');
                    }
                };
            });
        }

        // FIX 3: Migration - Fehlende gastro_id nachtr√§glich vergeben
        // Diese Funktion repariert bestehende Lebensmittel ohne gastro_id
        async function migrateLebensmittelGastroIds() {
            const lmOhneGastroId = lebensmittelData.filter(lm => !lm.gastro_id);

            if (lmOhneGastroId.length === 0) {
                console.log('‚úì Alle Lebensmittel haben bereits eine gastro_id');
                return;
            }

            console.log(`üîß MIGRATION: ${lmOhneGastroId.length} Lebensmittel ohne gastro_id gefunden`);

            // Finde h√∂chste bestehende gastro_id
            let nextId = lebensmittelData.reduce((max, lm) => {
                return (lm.gastro_id && lm.gastro_id > max) ? lm.gastro_id : max;
            }, 280) + 1; // Start nach h√∂chster GASTRO_DATENBANK ID

            // Alle Lebensmittel ohne gastro_id migrieren
            for (const lm of lmOhneGastroId) {
                lm.gastro_id = nextId++;
                await updateLebensmittel(lm.id, lm);
                console.log(`  ‚úì ${lm.name} ‚Üí gastro_id: ${lm.gastro_id}`);
            }

            // Daten neu laden
            await loadLebensmittel();
            console.log(`‚úÖ MIGRATION ABGESCHLOSSEN - ${lmOhneGastroId.length} Lebensmittel aktualisiert`);
        }

        // ===== ZUBEREITUNGSSCHRITTE HELPER-FUNKTIONEN =====
        // Diese Funktionen werden vom Rezept-Edit-Modal verwendet

        // Zubereitungsschritte dynamisch hinzuf√ºgen
        function addZubereitungsSchritt(text = '') {
            const container = document.getElementById('rzZubereitungContainer');
            const index = container.children.length;

            const div = document.createElement('div');
            div.className = 'zutat-row';
            div.style.cssText = 'display: flex; gap: 0.5rem; margin-bottom: 0.75rem; align-items: start;';
            div.innerHTML = `
                <span style="padding: 0.75rem; background: var(--dakota-gold); color: white; border-radius: 4px; font-weight: bold; min-width: 45px; text-align: center; font-size: 1.1rem;">
                    ${index + 1}
                </span>
                <textarea class="form-textarea rz-zubereitung-schritt" rows="2"
                          placeholder="Zubereitungsschritt ${index + 1}..."
                          style="flex: 1;">${text}</textarea>
                <button type="button" class="btn-icon delete" onclick="this.parentElement.remove(); updateZubereitungsNummern();" title="Schritt entfernen">üóëÔ∏è</button>
            `;

            container.appendChild(div);
        }

        // Nummerierung der Zubereitungsschritte aktualisieren
        function updateZubereitungsNummern() {
            const container = document.getElementById('rzZubereitungContainer');
            Array.from(container.children).forEach((div, index) => {
                const numSpan = div.querySelector('span');
                if (numSpan) numSpan.textContent = index + 1;
                const textarea = div.querySelector('textarea');
                if (textarea) textarea.placeholder = `Zubereitungsschritt ${index + 1}...`;
            });
        }

        // ===== FIRESTORE HELPER-FUNKTIONEN =====
        // Hybrid-Architektur: IndexedDB (lokal/schnell) + Firestore (Cloud/Sync)

        let firestoreSyncEnabled = false;
        let firestoreListeners = [];
        let isSyncing = false; // FIX 3: Flag um Listener w√§hrend Import/Migration zu ignorieren

        // Wait for Firebase to be initialized
        async function waitForFirebase() {
            let attempts = 0;
            while (!window.firestoreDB && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            if (!window.firestoreDB) {
                console.error('‚ùå Firebase konnte nicht geladen werden');
                return false;
            }
            return true;
        }

        let listenersInitialized = false; // Verhindert doppelte Listener

        // Initialize Firestore Sync
        async function initFirestoreSync() {
            console.log('üîÑ Initialisiere Firestore-Synchronisation...');

            const ready = await waitForFirebase();
            if (!ready) {
                console.warn('‚ö†Ô∏è Firestore nicht verf√ºgbar, arbeite nur lokal');
                return;
            }

            try {
                // Anonymous Authentication
                const { signInAnonymously, onAuthStateChanged } = window.firebaseModules;

                onAuthStateChanged(window.firebaseAuth, async (user) => {
                    if (user) {
                        console.log('‚úÖ Firebase Auth: Angemeldet als', user.uid);
                        firestoreSyncEnabled = true;

                        // FIX 2: Migration ZUERST, dann Listener (verhindert Race Condition)
                        // Migriere lokale Daten zu Firestore (nur beim ersten Mal)
                        await checkAndMigrateToFirestore();

                        // Setup Echtzeit-Listeners NACH der Migration (nur einmal!)
                        if (!listenersInitialized) {
                            setupRealtimeListeners();
                            listenersInitialized = true;
                        }

                        // NEU: Initial-Sync bei jedem Start - Firestore ‚Üí IndexedDB
                        await performInitialSync();
                    } else {
                        console.log('üîê Melde an bei Firebase...');
                        await signInAnonymously(window.firebaseAuth);
                    }
                });

            } catch (error) {
                console.error('‚ùå Firestore Init Fehler:', error);
                firestoreSyncEnabled = false;
            }
        }

        // NEU: Initial Sync beim App-Start - holt neueste Daten von Firestore
        async function performInitialSync() {
            if (!firestoreSyncEnabled || isSyncing) return;

            console.log('üîÑ F√ºhre Initial-Sync durch (Firestore ‚Üí Lokal)...');
            isSyncing = true;

            try {
                const { collection, getDocs } = window.firebaseModules;

                // Lade alle Collections von Firestore
                const [lmSnapshot, rzSnapshot, mkSnapshot] = await Promise.all([
                    getDocs(collection(window.firestoreDB, 'lebensmittel')),
                    getDocs(collection(window.firestoreDB, 'rezepte')),
                    getDocs(collection(window.firestoreDB, 'menuekarten'))
                ]);

                // Sync Lebensmittel
                let lmCount = 0;
                for (const doc of lmSnapshot.docs) {
                    const data = { ...doc.data(), id: parseInt(doc.id, 10) };
                    await syncFromFirestoreToIndexedDB('lebensmittel', data);
                    lmCount++;
                }

                // Sync Rezepte
                let rzCount = 0;
                for (const doc of rzSnapshot.docs) {
                    const data = { ...doc.data(), id: parseInt(doc.id, 10) };
                    await syncFromFirestoreToIndexedDB('rezepte', data);
                    rzCount++;
                }

                // Sync Men√ºkarten
                let mkCount = 0;
                for (const doc of mkSnapshot.docs) {
                    const data = { ...doc.data(), id: parseInt(doc.id, 10) };
                    await syncFromFirestoreToIndexedDB('menuekarten', data);
                    mkCount++;
                }

                console.log(`‚úÖ Initial-Sync abgeschlossen: ${lmCount} Lebensmittel, ${rzCount} Rezepte, ${mkCount} Men√ºkarten`);

                // UI aktualisieren
                await loadLebensmittel();
                await loadRezepte();
                await loadMenuekartenTab();
                updateStats();

                // Speichere letzten Sync-Zeitpunkt
                localStorage.setItem('dakota_last_sync', new Date().toISOString());

            } catch (error) {
                console.error('‚ùå Initial-Sync fehlgeschlagen:', error);
            } finally {
                isSyncing = false;
            }
        }

        // Sync bei Tab-Wechsel / Visibility Change
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && firestoreSyncEnabled && !isSyncing) {
                console.log('üëÅÔ∏è Tab wieder sichtbar - pr√ºfe auf Updates...');
                setTimeout(() => {
                    if (!isSyncing) {
                        performInitialSync();
                    }
                }, 500);
            }
        });

        // Sync bei Fokus (nach 30s Inaktivit√§t)
        window.addEventListener('focus', () => {
            if (firestoreSyncEnabled && !isSyncing) {
                const lastSync = localStorage.getItem('dakota_last_sync');
                const now = new Date();
                if (!lastSync || (now - new Date(lastSync)) > 30000) {
                    console.log('üîÑ Window fokussiert - sync nach 30s Inaktivit√§t...');
                    setTimeout(() => {
                        if (!isSyncing) {
                            performInitialSync();
                        }
                    }, 500);
                }
            }
        });

        // Setup Realtime Listeners f√ºr alle 3 Collections
        function setupRealtimeListeners() {
            const { collection, onSnapshot } = window.firebaseModules;

            // Listener: Lebensmittel
            const lmUnsubscribe = onSnapshot(
                collection(window.firestoreDB, 'lebensmittel'),
                (snapshot) => {
                    // FIX 3: Ignoriere √Ñnderungen w√§hrend Import/Migration
                    if (isSyncing) {
                        console.log('‚è≥ Lebensmittel-Listener pausiert w√§hrend Import/Migration');
                        return;
                    }

                    snapshot.docChanges().forEach(async (change) => {
                        // FIX: ID als Number parsen (Firestore IDs sind Strings, IndexedDB braucht Numbers)
                        const data = {
                            ...change.doc.data(),
                            id: parseInt(change.doc.id, 10)
                        };

                        if (change.type === 'added' || change.type === 'modified') {
                            // Update IndexedDB lokal
                            await syncFromFirestoreToIndexedDB('lebensmittel', data);
                        } else if (change.type === 'removed') {
                            await deleteFromIndexedDB('lebensmittel', parseInt(change.doc.id, 10));
                        }
                    });

                    // UI refresh
                    if (document.querySelector('#tab-lebensmittel.active')) {
                        loadLebensmittel();
                    }
                },
                (error) => console.error('Lebensmittel Listener Error:', error)
            );

            // Listener: Rezepte
            const rzUnsubscribe = onSnapshot(
                collection(window.firestoreDB, 'rezepte'),
                (snapshot) => {
                    // FIX 3: Ignoriere √Ñnderungen w√§hrend Import/Migration
                    if (isSyncing) {
                        console.log('‚è≥ Rezepte-Listener pausiert w√§hrend Import/Migration');
                        return;
                    }

                    snapshot.docChanges().forEach(async (change) => {
                        // FIX: ID als Number parsen (Firestore IDs sind Strings, IndexedDB braucht Numbers)
                        const data = {
                            ...change.doc.data(),
                            id: parseInt(change.doc.id, 10)
                        };

                        if (change.type === 'added' || change.type === 'modified') {
                            await syncFromFirestoreToIndexedDB('rezepte', data);
                        } else if (change.type === 'removed') {
                            await deleteFromIndexedDB('rezepte', parseInt(change.doc.id, 10));
                        }
                    });

                    if (document.querySelector('#tab-rezepte.active')) {
                        loadRezepte();
                    }
                },
                (error) => console.error('Rezepte Listener Error:', error)
            );

            // Listener: Men√ºkarten
            const mkUnsubscribe = onSnapshot(
                collection(window.firestoreDB, 'menuekarten'),
                (snapshot) => {
                    // FIX 3: Ignoriere √Ñnderungen w√§hrend Import/Migration
                    if (isSyncing) {
                        console.log('‚è≥ Men√ºkarten-Listener pausiert w√§hrend Import/Migration');
                        return;
                    }

                    snapshot.docChanges().forEach(async (change) => {
                        // FIX: ID als Number parsen (Firestore IDs sind Strings, IndexedDB braucht Numbers)
                        const data = {
                            ...change.doc.data(),
                            id: parseInt(change.doc.id, 10)
                        };

                        if (change.type === 'added' || change.type === 'modified') {
                            await syncFromFirestoreToIndexedDB('menuekarten', data);
                        } else if (change.type === 'removed') {
                            await deleteFromIndexedDB('menuekarten', parseInt(change.doc.id, 10));
                        }
                    });

                    if (document.querySelector('#tab-menuekarten.active')) {
                        loadMenuekartenTab();
                    }
                },
                (error) => console.error('Men√ºkarten Listener Error:', error)
            );

            firestoreListeners.push(lmUnsubscribe, rzUnsubscribe, mkUnsubscribe);
            console.log('‚úÖ Echtzeit-Listeners aktiviert');
        }

        // Sync: Firestore ‚Üí IndexedDB
        async function syncFromFirestoreToIndexedDB(storeName, data) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);

                // FIX: Sicherstellen dass ID ein Number ist (Firestore liefert Strings)
                if (typeof data.id === 'string') {
                    data.id = parseInt(data.id, 10);
                }

                // Pr√ºfe ob existiert
                const getRequest = store.get(data.id);

                getRequest.onsuccess = () => {
                    const existing = getRequest.result;

                    // Update nur wenn Firestore-Version neuer ist
                    if (!existing || !existing._firestoreTimestamp ||
                        data._firestoreTimestamp > existing._firestoreTimestamp) {

                        // FIX: Men√ºkarten - Daten validieren beim Laden aus Firestore
                        if (storeName === 'menuekarten' && data.gerichte) {
                            // Sicherstellen dass gerichte ein Array ist (nicht Object/Map)
                            if (!Array.isArray(data.gerichte)) {
                                console.warn(`‚ö†Ô∏è Repariere ${data.name}: gerichte war Object, konvertiere zu Array`);
                                data.gerichte = Object.values(data.gerichte);
                            }

                            // Datentypen forcieren: rezept_id und reihenfolge als Numbers
                            data.gerichte = data.gerichte.map(g => ({
                                ...g,
                                rezept_id: typeof g.rezept_id === 'string' ? parseInt(g.rezept_id, 10) : (g.rezept_id || 0),
                                reihenfolge: typeof g.reihenfolge === 'string' ? parseInt(g.reihenfolge, 10) : (g.reihenfolge || 0),
                                kategorie: g.kategorie || ''
                            }));
                        }

                        store.put(data);
                    }
                };

                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        // Delete from IndexedDB
        async function deleteFromIndexedDB(storeName, docId) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                store.delete(docId);

                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        // Sync: IndexedDB ‚Üí Firestore
        async function syncToFirestore(storeName, data) {
            if (!firestoreSyncEnabled) return;

            try {
                const { doc, setDoc } = window.firebaseModules;
                const docRef = doc(window.firestoreDB, storeName, String(data.id));

                // Timestamp hinzuf√ºgen
                const dataWithTimestamp = {
                    ...data,
                    _firestoreTimestamp: Date.now(),
                    _lastModified: new Date().toISOString()
                };

                // FIX: Men√ºkarten - Arrays explizit sch√ºtzen, Datentypen forcieren
                if (storeName === 'menuekarten' && dataWithTimestamp.gerichte) {
                    // Sicherstellen dass gerichte ein Array ist (nicht Object/Map)
                    if (!Array.isArray(dataWithTimestamp.gerichte)) {
                        console.warn('‚ö†Ô∏è gerichte war kein Array, konvertiere zu Array');
                        dataWithTimestamp.gerichte = Object.values(dataWithTimestamp.gerichte);
                    }

                    // Datentypen forcieren: rezept_id und reihenfolge als Numbers
                    dataWithTimestamp.gerichte = dataWithTimestamp.gerichte.map(g => ({
                        ...g,
                        rezept_id: typeof g.rezept_id === 'string' ? parseInt(g.rezept_id, 10) : (g.rezept_id || 0),
                        reihenfolge: typeof g.reihenfolge === 'string' ? parseInt(g.reihenfolge, 10) : (g.reihenfolge || 0),
                        kategorie: g.kategorie || ''
                    }));
                }

                await setDoc(docRef, dataWithTimestamp, { merge: true });
                console.log(`‚úÖ Sync zu Firestore: ${storeName}/${data.id}`);

            } catch (error) {
                console.error(`‚ùå Firestore Sync Error (${storeName}):`, error);
            }
        }

        // Delete from Firestore
        async function deleteFromFirestore(storeName, docId) {
            if (!firestoreSyncEnabled) return;

            try {
                const { doc, deleteDoc } = window.firebaseModules;
                const docRef = doc(window.firestoreDB, storeName, String(docId));
                await deleteDoc(docRef);
                console.log(`üóëÔ∏è Gel√∂scht aus Firestore: ${storeName}/${docId}`);

            } catch (error) {
                console.error(`‚ùå Firestore Delete Error (${storeName}):`, error);
            }
        }

        // Migriere alle lokalen Daten zu Firestore (einmalig)
        async function checkAndMigrateToFirestore() {
            // Pr√ºfe ob bereits migriert
            const migrated = localStorage.getItem('firestore_migrated');
            if (migrated === 'true') {
                console.log('‚úì Daten bereits in Firestore vorhanden');
                return;
            }

            console.log('üöÄ Starte Migration: IndexedDB ‚Üí Firestore...');

            // FIX 3: Flag setzen um Firestore-Listener zu ignorieren w√§hrend Migration
            isSyncing = true;

            try {
                // Migriere Lebensmittel
                const lmCount = await migrateCollectionToFirestore('lebensmittel', lebensmittelData);
                console.log(`‚úÖ ${lmCount} Lebensmittel migriert`);

                // Migriere Rezepte
                const rzCount = await migrateCollectionToFirestore('rezepte', rezepteData);
                console.log(`‚úÖ ${rzCount} Rezepte migriert`);

                // Migriere Men√ºkarten
                const mkCount = await migrateCollectionToFirestore('menuekarten', menuekartenData);
                console.log(`‚úÖ ${mkCount} Men√ºkarten migriert`);

                // Markiere als migriert
                localStorage.setItem('firestore_migrated', 'true');

                alert(`üéâ Migration abgeschlossen!\n\n${lmCount} Lebensmittel\n${rzCount} Rezepte\n${mkCount} Men√ºkarten\n\nSind jetzt in der Cloud synchronisiert.`);

            } catch (error) {
                console.error('‚ùå Migration fehlgeschlagen:', error);
                alert(`‚ùå Migration fehlgeschlagen:\n\n${error.message}\n\nBitte Console pr√ºfen.`);
            } finally {
                // FIX 3: Flag zur√ºcksetzen (wird IMMER ausgef√ºhrt, auch bei Fehler)
                isSyncing = false;
            }
        }

        // Migriere eine Collection zu Firestore
        async function migrateCollectionToFirestore(storeName, dataArray) {
            if (!dataArray || dataArray.length === 0) return 0;

            let count = 0;
            for (const item of dataArray) {
                await syncToFirestore(storeName, item);
                count++;

                // Progress alle 10 Eintr√§ge
                if (count % 10 === 0) {
                    console.log(`  ${storeName}: ${count}/${dataArray.length}...`);
                }
            }

            return count;
        }

        // Manuelle Migration nur f√ºr Men√ºkarten (f√ºr Console)
        // Aufruf: window.manualMigrateMenuekarten()
        window.manualMigrateMenuekarten = async function () {
            if (!firestoreSyncEnabled) {
                console.error('‚ùå Firestore ist nicht aktiviert!');
                return;
            }

            console.log('üöÄ Starte manuelle Men√ºkarten-Migration...');

            // Men√ºkarten neu laden
            await loadMenuekarten();

            const mkCount = await migrateCollectionToFirestore('menuekarten', menuekartenData);
            console.log(`‚úÖ ${mkCount} Men√ºkarten zu Firestore migriert!`);

            alert(`üéâ Migration abgeschlossen!\n\n${mkCount} Men√ºkarten sind jetzt in Firestore.\n\n√ñffne Firebase Console um sie zu sehen.`);
        };

        // Repariere korrupte Men√ºkarten in Firestore (f√ºr Console)
        // Aufruf: window.repairMenuekartenInFirestore()
        window.repairMenuekartenInFirestore = async function () {
            if (!firestoreSyncEnabled) {
                console.error('‚ùå Firestore ist nicht aktiviert!');
                return;
            }

            console.log('üîß Starte Reparatur von Men√ºkarten in Firestore...');

            try {
                const { collection, getDocs, doc, setDoc } = window.firebaseModules;
                const querySnapshot = await getDocs(collection(window.firestoreDB, 'menuekarten'));

                let repaired = 0;
                let total = 0;

                for (const docSnapshot of querySnapshot.docs) {
                    total++;
                    const data = docSnapshot.data();
                    let needsRepair = false;

                    console.log(`\nüìã Pr√ºfe: ${data.name} (ID: ${docSnapshot.id})`);

                    // Check 1: gerichte ist Array?
                    if (data.gerichte && !Array.isArray(data.gerichte)) {
                        console.log(`  ‚ö†Ô∏è gerichte ist Object/Map ‚Üí konvertiere zu Array`);
                        data.gerichte = Object.values(data.gerichte);
                        needsRepair = true;
                    }

                    // Check 2: rezept_id und reihenfolge als Numbers?
                    if (data.gerichte && Array.isArray(data.gerichte)) {
                        const before = JSON.stringify(data.gerichte);
                        data.gerichte = data.gerichte.map(g => ({
                            ...g,
                            rezept_id: typeof g.rezept_id === 'string' ? parseInt(g.rezept_id, 10) : (g.rezept_id || 0),
                            reihenfolge: typeof g.reihenfolge === 'string' ? parseInt(g.reihenfolge, 10) : (g.reihenfolge || 0),
                            kategorie: g.kategorie || ''
                        }));
                        const after = JSON.stringify(data.gerichte);

                        if (before !== after) {
                            console.log(`  ‚ö†Ô∏è Datentypen korrigiert (rezept_id, reihenfolge)`);
                            needsRepair = true;
                        }
                    }

                    // Reparatur durchf√ºhren
                    if (needsRepair) {
                        await setDoc(doc(window.firestoreDB, 'menuekarten', docSnapshot.id), data);
                        console.log(`  ‚úÖ Repariert und gespeichert`);
                        repaired++;
                    } else {
                        console.log(`  ‚úì OK, keine Reparatur n√∂tig`);
                    }
                }

                console.log(`\n‚úÖ Reparatur abgeschlossen!`);
                console.log(`   Gepr√ºft: ${total}`);
                console.log(`   Repariert: ${repaired}`);

                alert(`üéâ Reparatur abgeschlossen!\n\n‚Ä¢ ${total} Men√ºkarten gepr√ºft\n‚Ä¢ ${repaired} Men√ºkarten repariert\n\nDie Daten in Firestore sind jetzt korrekt!`);

            } catch (error) {
                console.error('‚ùå Reparatur fehlgeschlagen:', error);
                alert(`‚ùå Reparatur fehlgeschlagen:\n\n${error.message}\n\nBitte Console pr√ºfen.`);
            }
        };


        // ===== REZEPT-DATENBANK IMPORT =====

        // Auto-Import beim ersten Start (ohne Best√§tigungs-Dialog)

        // ===== DB OPERATIONS =====
        async function getAllLebensmittel() {
            // FIX: Warte auf DB-Initialisierung falls noch nicht bereit
            if (!db) {
                console.log('‚è≥ Warte auf IndexedDB...');
                await initDB();
            }
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['lebensmittel'], 'readonly');
                const store = transaction.objectStore('lebensmittel');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function addLebensmittel(data) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['lebensmittel'], 'readwrite');
                const store = transaction.objectStore('lebensmittel');

                // FIX: Timestamp SOFORT setzen um Duplikate durch Firestore-Listener zu verhindern
                data._firestoreTimestamp = Date.now();
                data._lastModified = new Date().toISOString();

                const request = store.add(data);
                request.onsuccess = async () => {
                    const newId = request.result;
                    data.id = newId;
                    // Sync zu Firestore
                    await syncToFirestore('lebensmittel', data);
                    resolve(newId);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function updateLebensmittel(id, data) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['lebensmittel'], 'readwrite');
                const store = transaction.objectStore('lebensmittel');

                // FIX: Timestamp aktualisieren um Duplikate zu verhindern
                data.id = id;
                data._firestoreTimestamp = Date.now();
                data._lastModified = new Date().toISOString();

                const request = store.put(data);
                request.onsuccess = async () => {
                    // Sync zu Firestore
                    await syncToFirestore('lebensmittel', data);
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteLebensmittel(id) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['lebensmittel'], 'readwrite');
                const store = transaction.objectStore('lebensmittel');
                const request = store.delete(id);
                request.onsuccess = async () => {
                    // Delete von Firestore
                    await deleteFromFirestore('lebensmittel', id);
                    resolve();
                };
                request.onerror = () => reject(request.error);
            });
        }

        // ===== GASTRO-DATENBANK IMPORT =====

        // NEU: Auto-Import von Firebase (statt embedded Datenbank)
        async function autoImportFromFirestore() {
            if (!firestoreSyncEnabled) {
                console.warn('‚ö†Ô∏è Firebase nicht verf√ºgbar - nutze JSON-Import als Fallback');
                alert('‚ö†Ô∏è Firebase-Verbindung nicht verf√ºgbar.\n\nBitte importiere die Daten manuell √ºber die JSON-Import Buttons.');
                return false;
            }

            console.log('üöÄ Erstinstallation: Lade Daten von Firebase...');

            // FIX 3: Flag setzen um Firestore-Listener zu ignorieren w√§hrend Import
            isSyncing = true;

            try {
                const { collection, getDocs } = window.firebaseModules;

                // Progress-Anzeige erstellen
                const progressDiv = document.createElement('div');
                progressDiv.id = 'firebase-import-progress';
                progressDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    padding: 2rem;
                    border-radius: 8px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                    z-index: 10000;
                    min-width: 400px;
                    text-align: center;
                `;
                progressDiv.innerHTML = `
                    <h3 style="margin-bottom: 1rem; color: var(--dakota-dark);">üöÄ Erstinstallation</h3>
                    <p style="color: #666; margin: 1rem 0;">Lade Daten von Firebase...</p>
                    <div style="margin: 1rem 0;">
                        <div style="background: #f0f0f0; height: 30px; border-radius: 15px; overflow: hidden;">
                            <div id="firebase-progress-bar" style="background: var(--dakota-gold); height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                    <p id="firebase-progress-text" style="color: #666; margin-top: 0.5rem;">Starte Download...</p>
                `;
                document.body.appendChild(progressDiv);

                const progressBar = document.getElementById('firebase-progress-bar');
                const progressText = document.getElementById('firebase-progress-text');

                // 1. Lebensmittel laden
                progressText.textContent = 'Lade Lebensmittel...';
                progressBar.style.width = '10%';

                const lmSnapshot = await getDocs(collection(window.firestoreDB, 'lebensmittel'));

                progressBar.style.width = '30%';
                progressText.textContent = `${lmSnapshot.size} Lebensmittel gefunden...`;

                let lmCount = 0;
                for (const doc of lmSnapshot.docs) {
                    const data = { ...doc.data(), id: parseInt(doc.id, 10) };
                    await syncFromFirestoreToIndexedDB('lebensmittel', data);
                    lmCount++;

                    // Progress update alle 50 Produkte
                    if (lmCount % 50 === 0) {
                        progressBar.style.width = `${30 + (lmCount / lmSnapshot.size * 30)}%`;
                    }
                }

                // 2. Rezepte laden
                progressBar.style.width = '60%';
                progressText.textContent = 'Lade Rezepte...';

                const rzSnapshot = await getDocs(collection(window.firestoreDB, 'rezepte'));

                progressBar.style.width = '70%';
                progressText.textContent = `${rzSnapshot.size} Rezepte gefunden...`;

                let rzCount = 0;
                for (const doc of rzSnapshot.docs) {
                    const data = { ...doc.data(), id: parseInt(doc.id, 10) };
                    await syncFromFirestoreToIndexedDB('rezepte', data);
                    rzCount++;

                    // Progress update alle 20 Rezepte
                    if (rzCount % 20 === 0) {
                        progressBar.style.width = `${70 + (rzCount / rzSnapshot.size * 30)}%`;
                    }
                }

                // Fertig!
                progressBar.style.width = '100%';
                progressText.textContent = 'Abgeschlossen!';

                // Warte kurz bevor Dialog geschlossen wird
                await new Promise(resolve => setTimeout(resolve, 500));
                progressDiv.remove();

                console.log(`‚úÖ Firebase Auto-Import abgeschlossen: ${lmCount} Produkte, ${rzCount} Rezepte`);

                // UI neu laden
                await loadLebensmittel();
                await loadRezepte();

                alert(`üéâ Erstinstallation abgeschlossen!\n\n${lmCount} Lebensmittel\n${rzCount} Rezepte\n\nvon Firebase geladen.`);

                return true;

            } catch (error) {
                console.error('‚ùå Firebase Auto-Import fehlgeschlagen:', error);
                document.getElementById('firebase-import-progress')?.remove();
                alert(`‚ùå Firebase-Import fehlgeschlagen:\n\n${error.message}\n\nBitte nutze die JSON-Import Buttons als Fallback.`);
                return false;
            } finally {
                // FIX 3: Flag zur√ºcksetzen (wird IMMER ausgef√ºhrt, auch bei Fehler)
                isSyncing = false;
            }
        }

        // Manueller Import mit Best√§tigungs-Dialog

        // ===== JSON-IMPORT FUNKTIONEN =====

        // Import Lebensmittel aus JSON-Datei
        async function importLebensmittelJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!Array.isArray(data)) {
                    alert('‚ùå Fehler: JSON-Datei muss ein Array enthalten!');
                    return;
                }

                const confirmed = confirm(`üì• Lebensmittel Import\n\n${data.length} Lebensmittel gefunden.\n\nM√∂chten Sie diese importieren?`);
                if (!confirmed) return;

                let imported = 0;
                let skipped = 0;

                for (const item of data) {
                    try {
                        // Pr√ºfe ob bereits vorhanden (anhand gastro_id oder name)
                        const exists = lebensmittelData.find(lm =>
                            (item.gastro_id && lm.gastro_id === item.gastro_id) ||
                            lm.name === item.name
                        );

                        if (!exists) {
                            await addLebensmittel(item);
                            imported++;
                        } else {
                            skipped++;
                        }
                    } catch (err) {
                        console.error('Fehler beim Importieren:', item, err);
                    }
                }

                await loadLebensmittel();
                alert(`‚úÖ Import abgeschlossen!\n\n‚Ä¢ Importiert: ${imported}\n‚Ä¢ √úbersprungen (Duplikate): ${skipped}`);

                // Input zur√ºcksetzen
                event.target.value = '';

            } catch (error) {
                alert(`‚ùå Import fehlgeschlagen:\n\n${error.message}`);
                console.error('Import-Fehler:', error);
            }
        }

        // Import Rezepte aus JSON-Datei
        async function importRezepteJSON(event) {
            console.log('üì• Import gestartet...');
            const file = event.target.files[0];
            if (!file) {
                console.log('‚ùå Keine Datei ausgew√§hlt');
                return;
            }
            console.log('üìÑ Datei ausgew√§hlt:', file.name);

            try {
                const text = await file.text();
                console.log('üìÑ Datei gelesen, L√§nge:', text.length);
                const data = JSON.parse(text);
                console.log('‚úÖ JSON geparst, Anzahl Eintr√§ge:', data.length);

                if (!Array.isArray(data)) {
                    alert('‚ùå Fehler: JSON-Datei muss ein Array enthalten!');
                    return;
                }

                // Automatisch importieren ohne Best√§tigung (confirm kann von Browser blockiert werden)
                console.log(`üì• Starte Import von ${data.length} Rezepten...`);

                // FIX: Stelle sicher, dass DB und rezepteData geladen sind
                if (!db) {
                    console.log('‚è≥ Warte auf IndexedDB...');
                    await initDB();
                }
                if (!rezepteData || rezepteData.length === 0) {
                    console.log('‚è≥ Lade bestehende Rezepte...');
                    await loadRezepte();
                }
                console.log('üìä Bestehende Rezepte:', rezepteData.length);

                let imported = 0;
                let skipped = 0;
                let errors = 0;

                for (const item of data) {
                    try {
                        // Pr√ºfe ob bereits vorhanden (anhand name)
                        const exists = rezepteData.find(rz => rz.name === item.name);

                        if (!exists) {
                            console.log(`  ‚ûï Importiere: ${item.name}`);
                            await addRezept(item);
                            imported++;
                        } else {
                            console.log(`  ‚è≠Ô∏è √úberspringe (existiert): ${item.name}`);
                            skipped++;
                        }
                    } catch (err) {
                        console.error('‚ùå Fehler beim Importieren:', item.name, err);
                        errors++;
                    }
                }

                await loadRezepte();
                console.log(`‚úÖ Import abgeschlossen! Importiert: ${imported}, √úbersprungen: ${skipped}, Fehler: ${errors}`);
                alert(`‚úÖ Import abgeschlossen!\n\n‚Ä¢ Importiert: ${imported}\n‚Ä¢ √úbersprungen (Duplikate): ${skipped}${errors > 0 ? '\n‚Ä¢ Fehler: ' + errors : ''}`);

                // Input zur√ºcksetzen
                event.target.value = '';

            } catch (error) {
                alert(`‚ùå Import fehlgeschlagen:\n\n${error.message}`);
                console.error('Import-Fehler:', error);
            }
        }

        // Import Men√ºkarten aus JSON-Datei
        async function importMenuekartenJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!Array.isArray(data)) {
                    alert('‚ùå Fehler: JSON-Datei muss ein Array enthalten!');
                    return;
                }

                // Automatisch importieren ohne Best√§tigung
                console.log(`üì• Starte Import von ${data.length} Men√ºkarten...`);

                // Stelle sicher, dass Rezepte geladen sind
                if (!rezepteData || rezepteData.length === 0) {
                    console.log('‚è≥ Lade Rezepte...');
                    await loadRezepte();
                }

                let imported = 0;
                let skipped = 0;
                let notFoundRecipes = [];

                for (const item of data) {
                    try {
                        // Pr√ºfe ob bereits vorhanden (anhand name + typ)
                        const exists = menuekartenData.find(mk =>
                            mk.name === item.name && mk.typ === item.typ
                        );

                        if (!exists) {
                            // NEU: Wenn gerichte rezept_name statt rezept_id haben, aufl√∂sen
                            // ABER: Behalte rezept_name f√ºr sp√§tere Reparatur!
                            if (item.gerichte && item.gerichte.length > 0) {
                                const resolvedGerichte = [];
                                for (const gericht of item.gerichte) {
                                    if (gericht.rezept_name) {
                                        // Suche Rezept nach Name
                                        const rezept = rezepteData.find(r => r.name === gericht.rezept_name);
                                        if (rezept) {
                                            resolvedGerichte.push({
                                                rezept_id: rezept.id,
                                                rezept_name: gericht.rezept_name, // Behalte f√ºr Debug/Reparatur
                                                kategorie: gericht.kategorie || 'Hauptgang',
                                                wochentag: gericht.wochentag || ''
                                            });
                                            console.log(`  ‚úì Rezept gefunden: ${gericht.rezept_name} -> ID ${rezept.id}`);
                                        } else {
                                            // Rezept nicht gefunden - speichere trotzdem mit Name f√ºr sp√§tere Reparatur
                                            resolvedGerichte.push({
                                                rezept_id: -1, // Ung√ºltige ID als Marker
                                                rezept_name: gericht.rezept_name,
                                                kategorie: gericht.kategorie || 'Hauptgang',
                                                wochentag: gericht.wochentag || ''
                                            });
                                            notFoundRecipes.push(gericht.rezept_name);
                                            console.warn(`  ‚ö†Ô∏è Rezept nicht gefunden: ${gericht.rezept_name} (wird f√ºr Reparatur gespeichert)`);
                                        }
                                    } else if (gericht.rezept_id) {
                                        // Hat bereits rezept_id
                                        resolvedGerichte.push(gericht);
                                    }
                                }
                                item.gerichte = resolvedGerichte;
                            }

                            // Importiere auch wenn nicht alle Rezepte gefunden wurden - kann sp√§ter repariert werden
                            if (item.gerichte && item.gerichte.length > 0) {
                                await addMenuekarte(item);
                                imported++;
                                const validCount = item.gerichte.filter(g => g.rezept_id > 0).length;
                                console.log(`  ‚ûï Men√ºkarte importiert: ${item.name} (${validCount}/${item.gerichte.length} Gerichte verkn√ºpft)`);
                            } else {
                                console.warn(`  ‚è≠Ô∏è √úbersprungen (keine Gerichte): ${item.name}`);
                                skipped++;
                            }
                        } else {
                            console.log(`  ‚è≠Ô∏è √úbersprungen (existiert): ${item.name}`);
                            skipped++;
                        }
                    } catch (err) {
                        console.error('Fehler beim Importieren:', item, err);
                    }
                }

                await loadMenuekarten();
                await loadMenuekartenTab();

                let message = `‚úÖ Import abgeschlossen!\n\n‚Ä¢ Importiert: ${imported}\n‚Ä¢ √úbersprungen: ${skipped}`;
                if (notFoundRecipes.length > 0) {
                    message += `\n\n‚ö†Ô∏è ${notFoundRecipes.length} Rezepte nicht gefunden:\n${notFoundRecipes.slice(0, 5).join('\n')}`;
                    if (notFoundRecipes.length > 5) message += `\n... und ${notFoundRecipes.length - 5} weitere`;
                }
                alert(message);

                // Input zur√ºcksetzen
                event.target.value = '';

            } catch (error) {
                alert(`‚ùå Import fehlgeschlagen:\n\n${error.message}`);
                console.error('Import-Fehler:', error);
            }
        }

        // ===== EXPORT-FUNKTIONEN =====

        // Export Lebensmittel zu JSON-Datei
        async function exportLebensmittelJSON() {
            try {
                console.log('üì§ Exportiere Lebensmittel...');

                // Daten DIREKT aus IndexedDB holen (nicht aus globalem Array!)
                const data = await getAllLebensmittel();

                if (!data || data.length === 0) {
                    alert('‚ö†Ô∏è Keine Lebensmittel zum Exportieren vorhanden!');
                    return;
                }

                // JSON erstellen
                const json = JSON.stringify(data, null, 2);

                // Download
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dakota-lebensmittel-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log(`‚úÖ ${data.length} Lebensmittel exportiert`);
                alert(`‚úÖ Export erfolgreich!\n\n${data.length} Lebensmittel wurden exportiert.`);

            } catch (error) {
                console.error('‚ùå Export-Fehler:', error);
                alert(`‚ùå Export fehlgeschlagen:\n\n${error.message}`);
            }
        }

        // Export Rezepte zu JSON-Datei
        async function exportRezepteJSON() {
            try {
                console.log('üì§ Exportiere Rezepte...');

                // Daten DIREKT aus IndexedDB holen (nicht aus globalem Array!)
                const data = await getAllRezepte();

                if (!data || data.length === 0) {
                    alert('‚ö†Ô∏è Keine Rezepte zum Exportieren vorhanden!');
                    return;
                }

                // JSON erstellen
                const json = JSON.stringify(data, null, 2);

                // Download
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dakota-rezepte-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log(`‚úÖ ${data.length} Rezepte exportiert`);
                alert(`‚úÖ Export erfolgreich!\n\n${data.length} Rezepte wurden exportiert.`);

            } catch (error) {
                console.error('‚ùå Export-Fehler:', error);
                alert(`‚ùå Export fehlgeschlagen:\n\n${error.message}`);
            }
        }

        // Export Men√ºkarten zu JSON-Datei
        async function exportMenuekartenJSON() {
            try {
                console.log('üì§ Exportiere Men√ºkarten...');

                // Daten DIREKT aus IndexedDB holen (nicht aus globalem Array!)
                const data = await getAllMenuekarten();

                if (!data || data.length === 0) {
                    alert('‚ö†Ô∏è Keine Men√ºkarten zum Exportieren vorhanden!');
                    return;
                }

                // JSON erstellen
                const json = JSON.stringify(data, null, 2);

                // Download
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dakota-menuekarten-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log(`‚úÖ ${data.length} Men√ºkarten exportiert`);
                alert(`‚úÖ Export erfolgreich!\n\n${data.length} Men√ºkarten wurden exportiert.`);

            } catch (error) {
                console.error('‚ùå Export-Fehler:', error);
                alert(`‚ùå Export fehlgeschlagen:\n\n${error.message}`);
            }
        }

        // ===== REZEPT-IMPORT =====

        async function getAllRezepte() {
            // FIX: Warte auf DB-Initialisierung falls noch nicht bereit
            if (!db) {
                console.log('‚è≥ Warte auf IndexedDB...');
                await initDB();
            }
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['rezepte'], 'readonly');
                const store = transaction.objectStore('rezepte');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function addRezept(data) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['rezepte'], 'readwrite');
                const store = transaction.objectStore('rezepte');

                // FIX: Timestamp SOFORT setzen um Duplikate durch Firestore-Listener zu verhindern
                data._firestoreTimestamp = Date.now();
                data._lastModified = new Date().toISOString();

                const request = store.add(data);
                request.onsuccess = async () => {
                    const newId = request.result;
                    data.id = newId;
                    // Sync zu Firestore
                    await syncToFirestore('rezepte', data);
                    resolve(newId);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function updateRezept(id, data) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['rezepte'], 'readwrite');
                const store = transaction.objectStore('rezepte');

                // FIX: Timestamp aktualisieren um Duplikate zu verhindern
                data.id = id;
                data._firestoreTimestamp = Date.now();
                data._lastModified = new Date().toISOString();

                const request = store.put(data);
                request.onsuccess = async () => {
                    // Sync zu Firestore
                    await syncToFirestore('rezepte', data);
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteRezept(id) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['rezepte'], 'readwrite');
                const store = transaction.objectStore('rezepte');
                const request = store.delete(id);
                request.onsuccess = async () => {
                    // Delete von Firestore
                    await deleteFromFirestore('rezepte', id);
                    resolve();
                };
                request.onerror = () => reject(request.error);
            });
        }

        // ===== MEN√ºKARTEN DB OPERATIONS =====
        async function getAllMenuekarten() {
            // FIX: Warte auf DB-Initialisierung falls noch nicht bereit
            if (!db) {
                console.log('‚è≥ Warte auf IndexedDB...');
                await initDB();
            }
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['menuekarten'], 'readonly');
                const store = transaction.objectStore('menuekarten');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function addMenuekarte(data) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['menuekarten'], 'readwrite');
                const store = transaction.objectStore('menuekarten');

                // FIX: Timestamp SOFORT setzen um Duplikate durch Firestore-Listener zu verhindern
                data._firestoreTimestamp = Date.now();
                data._lastModified = new Date().toISOString();

                const request = store.add(data);
                request.onsuccess = async () => {
                    const newId = request.result;
                    data.id = newId;
                    // Sync zu Firestore
                    await syncToFirestore('menuekarten', data);
                    resolve(newId);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function updateMenuekarte(id, data) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['menuekarten'], 'readwrite');
                const store = transaction.objectStore('menuekarten');

                // FIX: Timestamp aktualisieren um Duplikate zu verhindern
                data.id = id;
                data._firestoreTimestamp = Date.now();
                data._lastModified = new Date().toISOString();

                const request = store.put(data);
                request.onsuccess = async () => {
                    // Sync zu Firestore
                    await syncToFirestore('menuekarten', data);
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteMenuekarte(id) {
            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction(['menuekarten'], 'readwrite');
                const store = transaction.objectStore('menuekarten');
                const request = store.delete(id);
                request.onsuccess = async () => {
                    // Delete von Firestore
                    await deleteFromFirestore('menuekarten', id);
                    resolve();
                };
                request.onerror = () => reject(request.error);
            });
        }

        // ===== GLOBAL SEARCH =====
        function initGlobalSearch() {
            const searchInput = document.getElementById('globalSearchInput');
            const searchResults = document.getElementById('globalSearchResults');

            if (!searchInput || !searchResults) return;

            // Keyboard shortcut Ctrl+K
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                    e.preventDefault();
                    searchInput.focus();
                    searchInput.select();
                }
                // ESC to close
                if (e.key === 'Escape') {
                    searchResults.classList.remove('active');
                    searchInput.blur();
                }
            });

            // Search on input
            let searchTimeout;
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    performGlobalSearch(searchInput.value.trim());
                }, 150);
            });

            // Focus/Blur handlers
            searchInput.addEventListener('focus', () => {
                if (searchInput.value.trim().length >= 2) {
                    performGlobalSearch(searchInput.value.trim());
                }
            });

            // Close when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.global-search-container')) {
                    searchResults.classList.remove('active');
                }
            });
        }

        function performGlobalSearch(query) {
            const searchResults = document.getElementById('globalSearchResults');

            if (query.length < 2) {
                searchResults.classList.remove('active');
                return;
            }

            const queryLower = query.toLowerCase();
            let html = '';
            let totalResults = 0;

            // Search in Lebensmittel
            const matchingLebensmittel = lebensmittelData.filter(item =>
                item.name.toLowerCase().includes(queryLower) ||
                (item.kategorie && item.kategorie.toLowerCase().includes(queryLower)) ||
                (item.lieferant && item.lieferant.toLowerCase().includes(queryLower))
            ).slice(0, 5);

            if (matchingLebensmittel.length > 0) {
                totalResults += matchingLebensmittel.length;
                html += `
                    <div class="search-result-group">
                        <div class="search-result-group-title">ü•ï Lebensmittel (${matchingLebensmittel.length})</div>
                        ${matchingLebensmittel.map(item => `
                            <div class="search-result-item" onclick="navigateToLebensmittel(${item.id})">
                                <span class="search-result-icon">ü•ï</span>
                                <div class="search-result-info">
                                    <div class="search-result-name">${highlightMatch(item.name, query)}</div>
                                    <div class="search-result-detail">${item.kategorie || 'Keine Kategorie'} ‚Ä¢ CHF ${item.preis?.toFixed(2) || '0.00'}/${item.einheit || 'Stk'}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Search in Rezepte
            const matchingRezepte = rezepteData.filter(item =>
                item.name.toLowerCase().includes(queryLower) ||
                (item.kategorie && item.kategorie.toLowerCase().includes(queryLower)) ||
                (item.beschreibung && item.beschreibung.toLowerCase().includes(queryLower))
            ).slice(0, 5);

            if (matchingRezepte.length > 0) {
                totalResults += matchingRezepte.length;
                html += `
                    <div class="search-result-group">
                        <div class="search-result-group-title">üìñ Rezepte (${matchingRezepte.length})</div>
                        ${matchingRezepte.map(item => `
                            <div class="search-result-item" onclick="navigateToRezept(${item.id})">
                                <span class="search-result-icon">üìñ</span>
                                <div class="search-result-info">
                                    <div class="search-result-name">${highlightMatch(item.name, query)}</div>
                                    <div class="search-result-detail">${item.kategorie || 'Keine Kategorie'} ‚Ä¢ CHF ${item.verkaufspreis?.toFixed(2) || '0.00'}</div>
                                </div>
                                ${item.verkaufspreis ? `<span class="search-result-badge">${calculateRezeptFoodCostPercent(item)}%</span>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Search in Men√ºkarten
            const matchingMenuekarten = menuekartenData.filter(item =>
                item.name.toLowerCase().includes(queryLower) ||
                (item.typ && item.typ.toLowerCase().includes(queryLower))
            ).slice(0, 3);

            if (matchingMenuekarten.length > 0) {
                totalResults += matchingMenuekarten.length;
                html += `
                    <div class="search-result-group">
                        <div class="search-result-group-title">üçΩÔ∏è Men√ºkarten (${matchingMenuekarten.length})</div>
                        ${matchingMenuekarten.map(item => `
                            <div class="search-result-item" onclick="navigateToMenuekarte(${item.id})">
                                <span class="search-result-icon">üçΩÔ∏è</span>
                                <div class="search-result-info">
                                    <div class="search-result-name">${highlightMatch(item.name, query)}</div>
                                    <div class="search-result-detail">${item.typ || 'Men√ºkarte'} ‚Ä¢ ${item.gerichte?.length || 0} Gerichte</div>
                                </div>
                                ${item.aktiv ? '<span class="search-result-badge">Aktiv</span>' : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            if (totalResults === 0) {
                html = `
                    <div class="search-no-results">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">üîç</div>
                        <div>Keine Ergebnisse f√ºr "<strong>${query}</strong>"</div>
                    </div>
                `;
            }

            searchResults.innerHTML = html;
            searchResults.classList.add('active');
        }

        function highlightMatch(text, query) {
            if (!text || !query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark style="background: rgba(219, 167, 101, 0.3); padding: 0 2px; border-radius: 2px;">$1</mark>');
        }

        function calculateRezeptFoodCostPercent(rezept) {
            if (!rezept.verkaufspreis) return 0;
            const wareneinsatz = calculateRezeptWareneinsatz(rezept);
            return (wareneinsatz / rezept.verkaufspreis * 100).toFixed(1);
        }

        function navigateToLebensmittel(id) {
            document.getElementById('globalSearchResults').classList.remove('active');
            document.getElementById('globalSearchInput').value = '';
            switchTab('lebensmittel');
            setTimeout(() => {
                openLebensmittelModal(id);
            }, 200);
        }

        function navigateToRezept(id) {
            document.getElementById('globalSearchResults').classList.remove('active');
            document.getElementById('globalSearchInput').value = '';
            switchTab('rezepte');
            setTimeout(() => {
                openRezeptModal(id);
            }, 200);
        }

        function navigateToMenuekarte(id) {
            document.getElementById('globalSearchResults').classList.remove('active');
            document.getElementById('globalSearchInput').value = '';
            switchTab('menuekarten');
            setTimeout(() => {
                openMenuekarteModal(id);
            }, 200);
        }

        // ===== TAB SWITCHING =====
        function switchTab(tabName) {
            // Remove active from all tabs
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // FIX: Finde den Button anhand des onclick-Attributs statt event.target
            // (event ist nicht als Parameter definiert und verursacht Fehler)
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => {
                const onclickStr = btn.getAttribute('onclick') || '';
                if (onclickStr.includes(`'${tabName}'`) || onclickStr.includes(`"${tabName}"`)) {
                    btn.classList.add('active');
                }
            });

            document.getElementById('tab-' + tabName).classList.add('active');

            // Load data for tab
            if (tabName === 'lebensmittel') loadLebensmittel();
            if (tabName === 'rezepte') loadRezepte();
            if (tabName === 'kalkulation') loadKalkulationTab();
            if (tabName === 'einkaufsliste') loadEinkaufslisteTab();
            if (tabName === 'menuekarten') loadMenuekartenTab();
            if (tabName === 'einstellungen') loadEinstellungenTab();
            if (tabName === 'dienstplan') initDienstplan();
        }

        // ===== LEBENSMITTEL FUNCTIONS =====
        async function loadLebensmittel() {
            lebensmittelData = await getAllLebensmittel();
            renderLebensmittelTable(lebensmittelData);
            updateStats();
        }

        function renderLebensmittelTable(data) {
            const container = document.getElementById('lebensmittelTable');

            if (data.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ü•ï</div>
                        <div class="empty-state-text">Noch keine Lebensmittel vorhanden</div>
                        <button class="btn btn-primary" onclick="openLebensmittelModal()">
                            ‚ûï Erstes Lebensmittel hinzuf√ºgen
                        </button>
                    </div>
                `;
                return;
            }

            let html = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Kategorie</th>
                            <th>Saison</th>
                            <th>Preis/Einheit</th>
                            <th>Einheit</th>
                            <th>R√ºstverlust</th>
                            <th>Garverlust</th>
                            <th>Lieferant</th>
                            <th>Aktionen</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            data.forEach(lm => {
                const saisonStatus = getSaisonStatus(lm.saison);
                html += `
                    <tr>
                        <td><strong>${lm.name}</strong></td>
                        <td><span class="badge badge-gold">${lm.kategorie}</span></td>
                        <td><span class="saison-badge ${saisonStatus.class}">üåø ${saisonStatus.label}</span></td>
                        <td>CHF ${lm.preis.toFixed(2)}</td>
                        <td>${lm.einheit}</td>
                        <td>${lm.ruestverlust || 0}%</td>
                        <td>${lm.garverlust || 0}%</td>
                        <td>${lm.lieferant || '-'}</td>
                        <td class="action-buttons">
                            <button class="btn-icon" onclick="editLebensmittel(${lm.id})" title="Bearbeiten">‚úèÔ∏è</button>
                            <button class="btn-icon delete" onclick="confirmDeleteLebensmittel(${lm.id})" title="L√∂schen">üóëÔ∏è</button>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function searchLebensmittel() {
            const query = document.getElementById('searchLebensmittel').value.toLowerCase();
            const filtered = lebensmittelData.filter(lm =>
                lm.name.toLowerCase().includes(query) ||
                lm.kategorie.toLowerCase().includes(query) ||
                (lm.lieferant && lm.lieferant.toLowerCase().includes(query))
            );
            renderLebensmittelTable(filtered);
        }

        function filterLebensmittel() {
            const kategorie = document.getElementById('filterKategorie').value;
            if (!kategorie) {
                renderLebensmittelTable(lebensmittelData);
                return;
            }
            const filtered = lebensmittelData.filter(lm => lm.kategorie === kategorie);
            renderLebensmittelTable(filtered);
        }

        // Saison-Status berechnen
        function getSaisonStatus(saison) {
            if (!saison || !Array.isArray(saison) || saison.length === 0) {
                return { status: 'ganzjaehrig', label: 'Ganzj√§hrig', class: 'in-saison' };
            }

            const currentMonth = new Date().getMonth() + 1; // 1-12
            const nextMonth = currentMonth === 12 ? 1 : currentMonth + 1;

            if (saison.includes(currentMonth)) {
                return { status: 'in-saison', label: 'In Saison', class: 'in-saison' };
            } else if (saison.includes(nextMonth)) {
                return { status: 'bald-saison', label: 'Bald in Saison', class: 'bald-saison' };
            } else {
                return { status: 'off-saison', label: 'Nicht in Saison', class: 'off-saison' };
            }
        }

        // Saison-Filter
        let currentSaisonFilter = 'alle';

        function filterBySaison(filter) {
            currentSaisonFilter = filter;

            // Button-Status aktualisieren
            document.querySelectorAll('.saison-filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.toLowerCase().includes(filter === 'alle' ? 'alle' : filter === 'in-saison' ? 'jetzt' : filter === 'bald-saison' ? 'bald' : 'nicht')) {
                    btn.classList.add('active');
                }
            });

            // Filter anwenden
            if (filter === 'alle') {
                renderLebensmittelTable(lebensmittelData);
                return;
            }

            const filtered = lebensmittelData.filter(lm => {
                const saisonStatus = getSaisonStatus(lm.saison);
                if (filter === 'in-saison') {
                    return saisonStatus.status === 'in-saison' || saisonStatus.status === 'ganzjaehrig';
                } else if (filter === 'bald-saison') {
                    return saisonStatus.status === 'bald-saison';
                } else if (filter === 'off-saison') {
                    return saisonStatus.status === 'off-saison';
                }
                return true;
            });

            renderLebensmittelTable(filtered);
        }

        // ===== SETTINGS & API-KEY FUNKTIONEN =====
        let currentLieferscheinBase64 = null;
        let scannerResults = [];

        // Settings aus IndexedDB laden
        async function getSetting(key) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('settings', 'readonly');
                const store = tx.objectStore('settings');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result?.value || null);
                request.onerror = () => reject(request.error);
            });
        }

        // Settings in IndexedDB speichern
        async function setSetting(key, value) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('settings', 'readwrite');
                const store = tx.objectStore('settings');
                const request = store.put({ key, value });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // API-Key speichern
        async function saveApiKey() {
            const input = document.getElementById('openaiApiKey');
            const apiKey = input.value.trim();

            if (!apiKey) {
                alert('‚ö†Ô∏è Bitte gib einen API-Key ein!');
                return;
            }

            if (!apiKey.startsWith('sk-')) {
                alert('‚ö†Ô∏è Ung√ºltiges Format! OpenAI API-Keys beginnen mit "sk-"');
                return;
            }

            try {
                await setSetting('openai_api_key', apiKey);
                updateApiKeyStatus(true);
                alert('‚úÖ API-Key wurde gespeichert!');
            } catch (error) {
                console.error('‚ùå Fehler beim Speichern:', error);
                alert('‚ùå Fehler beim Speichern des API-Keys!');
            }
        }

        // API-Key laden und Status anzeigen
        async function loadApiKey() {
            try {
                const apiKey = await getSetting('openai_api_key');
                const input = document.getElementById('openaiApiKey');

                if (apiKey) {
                    // Zeige maskierten Key
                    input.value = apiKey;
                    updateApiKeyStatus(true);
                } else {
                    updateApiKeyStatus(false);
                }
            } catch (error) {
                console.error('‚ùå Fehler beim Laden:', error);
                updateApiKeyStatus(false);
            }
        }

        // API-Key Status anzeigen
        function updateApiKeyStatus(saved) {
            const status = document.getElementById('apiKeyStatus');
            if (saved) {
                status.className = 'api-key-status saved';
                status.innerHTML = '‚úÖ API-Key ist gespeichert und aktiv';
            } else {
                status.className = 'api-key-status missing';
                status.innerHTML = '‚ö†Ô∏è Kein API-Key gespeichert';
            }
        }

        // API-Key Sichtbarkeit umschalten
        function toggleApiKeyVisibility() {
            const input = document.getElementById('openaiApiKey');
            const toggle = document.querySelector('.api-key-toggle');
            if (input.type === 'password') {
                input.type = 'text';
                toggle.textContent = 'üôà';
            } else {
                input.type = 'password';
                toggle.textContent = 'üëÅÔ∏è';
            }
        }

        // API-Key testen
        async function testApiKey() {
            const apiKey = await getSetting('openai_api_key');

            if (!apiKey) {
                alert('‚ö†Ô∏è Kein API-Key gespeichert! Bitte zuerst einen Key eingeben.');
                return;
            }

            const status = document.getElementById('apiKeyStatus');
            status.innerHTML = 'üîÑ Teste API-Key...';
            status.className = 'api-key-status';

            try {
                // Versuche direkten API-Call, falls CORS-Fehler: nutze Proxy
                let response;
                try {
                    response = await fetch('https://api.openai.com/v1/models', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`
                        }
                    });
                } catch (corsError) {
                    // CORS-Fehler - versuche mit Proxy
                    console.log('‚ö†Ô∏è CORS beim Testen, nutze Proxy...');
                    response = await fetch('https://corsproxy.io/?' + encodeURIComponent('https://api.openai.com/v1/models'), {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`
                        }
                    });
                }

                if (response.ok) {
                    status.className = 'api-key-status saved';
                    status.innerHTML = '‚úÖ API-Key ist g√ºltig und funktioniert!';
                    alert('‚úÖ API-Key ist g√ºltig!');
                } else if (response.status === 401) {
                    status.className = 'api-key-status missing';
                    status.innerHTML = '‚ùå API-Key ist ung√ºltig!';
                    alert('‚ùå API-Key ist ung√ºltig oder abgelaufen!');
                } else {
                    status.className = 'api-key-status missing';
                    status.innerHTML = `‚ùå Fehler: ${response.status}`;
                    alert(`‚ùå Fehler beim Testen: Status ${response.status}`);
                }
            } catch (error) {
                console.error('‚ùå Test-Fehler:', error);
                status.className = 'api-key-status missing';
                status.innerHTML = '‚ùå Netzwerkfehler beim Testen';
                alert('‚ùå Netzwerkfehler! Bitte pr√ºfe deine Internetverbindung.');
            }
        }

        // ===== LIEFERSCHEIN SCANNER =====

        // Drag & Drop Setup
        function setupDragAndDrop() {
            const uploadZone = document.getElementById('uploadZone');
            if (!uploadZone) return;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                uploadZone.addEventListener(eventName, () => {
                    uploadZone.classList.add('dragover');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                uploadZone.addEventListener(eventName, () => {
                    uploadZone.classList.remove('dragover');
                }, false);
            });

            uploadZone.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleLieferscheinFile(files[0]);
                }
            }, false);
        }

        // Datei-Upload Handler
        function handleLieferscheinUpload(event) {
            const file = event.target.files[0];
            if (file) {
                handleLieferscheinFile(file);
            }
        }

        // Datei verarbeiten
        function handleLieferscheinFile(file) {
            // Validierung
            const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'application/pdf'];
            if (!validTypes.includes(file.type)) {
                alert('‚ö†Ô∏è Ung√ºltiger Dateityp! Bitte nutze JPG, PNG oder PDF.');
                return;
            }

            if (file.size > 20 * 1024 * 1024) {
                alert('‚ö†Ô∏è Datei ist zu gro√ü! Maximal 20MB erlaubt.');
                return;
            }

            // F√ºr PDF zeigen wir eine Placeholder-Vorschau
            if (file.type === 'application/pdf') {
                document.getElementById('previewImage').src = 'data:image/svg+xml,' + encodeURIComponent(`
                    <svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200">
                        <rect fill="#f5f5f5" width="200" height="200"/>
                        <text x="100" y="90" text-anchor="middle" font-size="48">üìÑ</text>
                        <text x="100" y="130" text-anchor="middle" font-size="16" fill="#666">PDF Datei</text>
                        <text x="100" y="150" text-anchor="middle" font-size="12" fill="#999">${file.name}</text>
                    </svg>
                `);
            }

            // Datei zu Base64 konvertieren
            const reader = new FileReader();
            reader.onload = (e) => {
                currentLieferscheinBase64 = e.target.result;

                // Vorschau anzeigen (f√ºr Bilder)
                if (file.type.startsWith('image/')) {
                    document.getElementById('previewImage').src = currentLieferscheinBase64;
                }

                document.getElementById('uploadPreview').classList.add('active');
                document.getElementById('uploadZone').style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        // Upload l√∂schen
        function clearLieferscheinUpload() {
            currentLieferscheinBase64 = null;
            document.getElementById('uploadPreview').classList.remove('active');
            document.getElementById('uploadZone').style.display = 'block';
            document.getElementById('lieferscheinInput').value = '';
            document.getElementById('scannerResults').style.display = 'none';
            document.getElementById('scannerLoading').style.display = 'none';
        }

        // Lieferschein analysieren mit GPT-4 Vision
        async function analyzeLieferschein() {
            if (!currentLieferscheinBase64) {
                alert('‚ö†Ô∏è Bitte erst einen Lieferschein hochladen!');
                return;
            }

            const apiKey = await getSetting('openai_api_key');
            if (!apiKey) {
                alert('‚ö†Ô∏è Bitte erst einen OpenAI API-Key eingeben!');
                return;
            }

            // Loading anzeigen
            document.getElementById('scannerLoading').style.display = 'block';
            document.getElementById('scannerResults').style.display = 'none';

            try {
                // OpenAI API Request mit korrekten CORS-Headern
                const requestBody = {
                    model: 'gpt-4o',
                    messages: [
                        {
                            role: 'system',
                            content: `Du bist ein Experte f√ºr die Analyse von Lieferscheinen in der Gastronomie.
Extrahiere alle Produkte mit Namen, Menge, Einheit und Preis pro Einheit.
Antworte NUR mit einem JSON-Array im folgenden Format:
[
    {
        "name": "Produktname",
        "menge": 5.0,
        "einheit": "kg",
        "preis_pro_einheit": 12.50,
        "kategorie": "Fleisch|Gem√ºse|K√§se|Fisch|..."
    }
]
Falls du etwas nicht lesen kannst, √ºberspringe es.
Preise in CHF, Komma als Dezimaltrennzeichen ersetzen durch Punkt.`
                        },
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: 'Analysiere diesen Lieferschein und extrahiere alle Produkte mit Preisen:'
                                },
                                {
                                    type: 'image_url',
                                    image_url: {
                                        url: currentLieferscheinBase64,
                                        detail: 'high'
                                    }
                                }
                            ]
                        }
                    ],
                    max_tokens: 4096
                };

                console.log('üì§ Sende Anfrage an OpenAI API...');

                // Versuche direkten API-Call (funktioniert lokal)
                // Falls CORS-Fehler: Nutze CORS-Proxy f√ºr GitHub Pages
                let response;
                let usedProxy = false;

                try {
                    response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });
                } catch (corsError) {
                    // CORS-Fehler - versuche mit Proxy
                    console.log('‚ö†Ô∏è CORS-Fehler, versuche mit Proxy...');
                    usedProxy = true;

                    // Verwende corsproxy.io als Fallback
                    response = await fetch('https://corsproxy.io/?' + encodeURIComponent('https://api.openai.com/v1/chat/completions'), {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });
                }

                if (usedProxy) {
                    console.log('‚úÖ Proxy-Anfrage erfolgreich');
                }

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) {
                        // Konnte Error nicht parsen
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                const content = data.choices[0].message.content;

                // JSON aus der Antwort extrahieren
                let products;
                try {
                    // Versuche direktes Parsing
                    products = JSON.parse(content);
                } catch {
                    // Versuche JSON aus Markdown-Block zu extrahieren
                    const jsonMatch = content.match(/```json?\s*([\s\S]*?)```/);
                    if (jsonMatch) {
                        products = JSON.parse(jsonMatch[1]);
                    } else {
                        // Versuche Array-Pattern zu finden
                        const arrayMatch = content.match(/\[[\s\S]*\]/);
                        if (arrayMatch) {
                            products = JSON.parse(arrayMatch[0]);
                        } else {
                            throw new Error('Konnte keine Produkte im Response finden');
                        }
                    }
                }

                if (!Array.isArray(products) || products.length === 0) {
                    throw new Error('Keine Produkte erkannt');
                }

                // Ergebnisse mit Datenbank abgleichen (verbessertes Matching)
                scannerResults = products.map(p => {
                    const matchResult = findMatchingLebensmittel(p.name);
                    const similarItems = findSimilarLebensmittel(p.name, 10);

                    let status = 'new';
                    let matchedLm = null;

                    if (matchResult) {
                        matchedLm = matchResult.match;
                        if (matchResult.type === 'exact') {
                            status = matchedLm.preis !== p.preis_pro_einheit ? 'update' : 'match';
                        } else {
                            // Partial match - Warnung anzeigen
                            status = 'similar';
                        }
                    }

                    return {
                        ...p,
                        matchedLm: matchedLm,
                        matchType: matchResult?.type || null,
                        matchScore: matchResult?.score || 0,
                        similarItems: similarItems,
                        status: status,
                        selectedAction: status === 'match' ? 'skip' : (status === 'update' ? 'update' : 'new'),
                        selectedLmId: matchedLm?.id || null,
                        selectedKategorie: p.kategorie || 'Sonstige'
                    };
                });

                displayScannerResults();

            } catch (error) {
                console.error('‚ùå Analyse-Fehler:', error);
                alert(`‚ùå Fehler bei der Analyse:\n${error.message}`);
            } finally {
                document.getElementById('scannerLoading').style.display = 'none';
            }
        }

        // Passenden Eintrag in Datenbank finden (verbessertes Fuzzy-Matching)
        function findMatchingLebensmittel(name) {
            const searchName = name.toLowerCase().trim();
            const searchWords = searchName.split(/\s+/);

            // 1. Exakte √úbereinstimmung
            let match = lebensmittelData.find(lm =>
                lm.name.toLowerCase() === searchName
            );
            if (match) return { match, score: 100, type: 'exact' };

            // 2. Name enth√§lt Suchbegriff oder umgekehrt
            match = lebensmittelData.find(lm =>
                lm.name.toLowerCase().includes(searchName) ||
                searchName.includes(lm.name.toLowerCase())
            );
            if (match) return { match, score: 80, type: 'contains' };

            // 3. Wortbasiertes Matching (mindestens 2 W√∂rter √ºbereinstimmend)
            for (const lm of lebensmittelData) {
                const lmWords = lm.name.toLowerCase().split(/\s+/);
                const matchingWords = searchWords.filter(sw =>
                    lmWords.some(lw => lw.includes(sw) || sw.includes(lw))
                );
                if (matchingWords.length >= 2 || (matchingWords.length === 1 && matchingWords[0].length > 4)) {
                    return { match: lm, score: 60, type: 'partial' };
                }
            }

            return null;
        }

        // Alle √§hnlichen Lebensmittel finden (f√ºr Dropdown)
        function findSimilarLebensmittel(name, limit = 10) {
            const searchName = name.toLowerCase().trim();
            const searchWords = searchName.split(/\s+/);

            const scored = lebensmittelData.map(lm => {
                const lmName = lm.name.toLowerCase();
                const lmWords = lmName.split(/\s+/);
                let score = 0;

                // Exakt
                if (lmName === searchName) score = 100;
                // Enth√§lt
                else if (lmName.includes(searchName) || searchName.includes(lmName)) score = 80;
                // Wort-Matching
                else {
                    const matchingWords = searchWords.filter(sw =>
                        lmWords.some(lw => lw.includes(sw) || sw.includes(lw))
                    );
                    score = matchingWords.length * 20;
                }

                return { lm, score };
            });

            return scored
                .filter(s => s.score > 0)
                .sort((a, b) => b.score - a.score)
                .slice(0, limit)
                .map(s => s.lm);
        }

        // Verf√ºgbare Kategorien
        const lebensmittelKategorien = [
            'Fleisch', 'Fisch & Meeresfr√ºchte', 'Gem√ºse', 'Obst', 'K√§se',
            'Milchprodukte', 'Eier', 'Brot & Backwaren', 'Teigwaren & Reis',
            'Gew√ºrze & Kr√§uter', '√ñle & Fette', 'Saucen & Fonds', 'N√ºsse & Samen',
            'H√ºlsenfr√ºchte', 'Konserven', 'Tiefk√ºhl', 'Getr√§nke', 'Spirituosen',
            'Wein', 'S√ºsswaren', 'Sonstige'
        ];

        // Scanner-Ergebnisse anzeigen (mit Zuordnungs- und Kategorie-Auswahl)
        function displayScannerResults() {
            const container = document.getElementById('scannerProductList');
            const resultsDiv = document.getElementById('scannerResults');
            const title = document.getElementById('resultsTitle');

            const newCount = scannerResults.filter(r => r.status === 'new').length;
            const updateCount = scannerResults.filter(r => r.status === 'update').length;
            const matchCount = scannerResults.filter(r => r.status === 'match').length;
            const similarCount = scannerResults.filter(r => r.status === 'similar').length;

            title.textContent = `${scannerResults.length} Produkte erkannt`;

            // Kategorie-Optionen generieren
            const kategorieOptions = lebensmittelKategorien.map(k =>
                `<option value="${k}">${k}</option>`
            ).join('');

            let html = '';
            scannerResults.forEach((item, index) => {
                // Status-Badge
                let statusBadge = '';
                let statusClass = item.status;
                if (item.status === 'match') {
                    statusBadge = '<span class="scanner-product-status match">‚úì Identisch</span>';
                } else if (item.status === 'update') {
                    statusBadge = '<span class="scanner-product-status update">‚Üë Preis-Update</span>';
                } else if (item.status === 'similar') {
                    statusBadge = '<span class="scanner-product-status similar" style="background: rgba(255,193,7,0.15); color: #856404;">‚ö†Ô∏è √Ñhnlich gefunden</span>';
                } else {
                    statusBadge = '<span class="scanner-product-status new">‚òÖ Neu</span>';
                }

                // √Ñhnliche Produkte f√ºr Dropdown
                const similarOptions = item.similarItems.map(lm =>
                    `<option value="${lm.id}" ${item.selectedLmId === lm.id ? 'selected' : ''}>${lm.name} (${lm.kategorie})</option>`
                ).join('');

                // Warnung bei √§hnlichem Produkt
                const warningHtml = item.status === 'similar' ? `
                    <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 0.5rem; margin-top: 0.5rem; font-size: 0.85rem;">
                        ‚ö†Ô∏è <strong>M√∂gliche Dopplung!</strong> "${item.matchedLm?.name}" existiert bereits.
                        Bitte pr√ºfen und unten zuordnen oder als neu anlegen.
                    </div>
                ` : '';

                html += `
                    <li class="scanner-product-item" style="flex-direction: column; align-items: stretch; gap: 0.75rem; padding: 1rem;">
                        <!-- Zeile 1: Produktinfo -->
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="scanner_item_${index}" ${item.status !== 'match' ? 'checked' : ''}>
                                <strong style="font-size: 1.05rem;">${item.name}</strong>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <span style="font-weight: 600; color: var(--dakota-gold);">
                                    CHF ${item.preis_pro_einheit?.toFixed(2) || '?'}/${item.einheit || '?'}
                                </span>
                                ${statusBadge}
                            </div>
                        </div>

                        ${warningHtml}

                        <!-- Zeile 2: Aktions-Auswahl -->
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; background: #f8f9fa; padding: 0.75rem; border-radius: 8px;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.85rem; font-weight: 500;">Aktion:</label>
                                <select id="scanner_action_${index}" onchange="updateScannerItemAction(${index})"
                                    style="padding: 0.4rem; border-radius: 6px; border: 1px solid #ddd; font-size: 0.9rem;">
                                    <option value="new" ${item.selectedAction === 'new' ? 'selected' : ''}>‚ûï Neu anlegen</option>
                                    <option value="update" ${item.selectedAction === 'update' ? 'selected' : ''}>üîÑ Bestehendes aktualisieren</option>
                                    <option value="skip" ${item.selectedAction === 'skip' ? 'selected' : ''}>‚è≠Ô∏è √úberspringen</option>
                                </select>
                            </div>

                            <!-- Zuordnung zu bestehendem Produkt -->
                            <div id="scanner_mapping_${index}" style="display: ${item.selectedAction === 'update' ? 'flex' : 'none'}; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.85rem; font-weight: 500;">Zuordnen zu:</label>
                                <select id="scanner_lm_${index}" onchange="updateScannerItemLm(${index})"
                                    style="padding: 0.4rem; border-radius: 6px; border: 1px solid #ddd; font-size: 0.9rem; max-width: 250px;">
                                    <option value="">-- Lebensmittel w√§hlen --</option>
                                    ${similarOptions}
                                    <option value="__all__">üìã Alle anzeigen...</option>
                                </select>
                            </div>

                            <!-- Kategorie f√ºr neue Produkte -->
                            <div id="scanner_kategorie_${index}" style="display: ${item.selectedAction === 'new' ? 'flex' : 'none'}; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.85rem; font-weight: 500;">Kategorie:</label>
                                <select id="scanner_kat_${index}" onchange="updateScannerItemKategorie(${index})"
                                    style="padding: 0.4rem; border-radius: 6px; border: 1px solid #ddd; font-size: 0.9rem;">
                                    ${kategorieOptions.replace(`value="${item.selectedKategorie}"`, `value="${item.selectedKategorie}" selected`)}
                                </select>
                            </div>

                            ${item.status === 'update' && item.matchedLm ? `
                                <div style="font-size: 0.85rem; color: #666;">
                                    Alter Preis: <span style="text-decoration: line-through;">CHF ${item.matchedLm.preis?.toFixed(2)}</span>
                                </div>
                            ` : ''}
                        </div>
                    </li>
                `;
            });

            container.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        // Aktion f√ºr Scanner-Item √§ndern
        function updateScannerItemAction(index) {
            const action = document.getElementById(`scanner_action_${index}`).value;
            scannerResults[index].selectedAction = action;

            // UI aktualisieren
            const mappingDiv = document.getElementById(`scanner_mapping_${index}`);
            const kategorieDiv = document.getElementById(`scanner_kategorie_${index}`);

            if (action === 'update') {
                mappingDiv.style.display = 'flex';
                kategorieDiv.style.display = 'none';
            } else if (action === 'new') {
                mappingDiv.style.display = 'none';
                kategorieDiv.style.display = 'flex';
            } else {
                mappingDiv.style.display = 'none';
                kategorieDiv.style.display = 'none';
            }

            // Checkbox entsprechend setzen
            document.getElementById(`scanner_item_${index}`).checked = (action !== 'skip');
        }

        // Lebensmittel-Zuordnung √§ndern
        function updateScannerItemLm(index) {
            const select = document.getElementById(`scanner_lm_${index}`);
            const value = select.value;

            if (value === '__all__') {
                // Alle Lebensmittel anzeigen
                const allOptions = lebensmittelData
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .map(lm => `<option value="${lm.id}">${lm.name} (${lm.kategorie})</option>`)
                    .join('');
                select.innerHTML = `<option value="">-- Lebensmittel w√§hlen --</option>${allOptions}`;
                select.value = '';
            } else {
                scannerResults[index].selectedLmId = value ? parseInt(value) : null;
            }
        }

        // Kategorie √§ndern
        function updateScannerItemKategorie(index) {
            const value = document.getElementById(`scanner_kat_${index}`).value;
            scannerResults[index].selectedKategorie = value;
        }

        // Scanner-Ergebnisse importieren (verbessert mit Aktions-Auswahl)
        async function importScannerResults() {
            // Aktuelle Auswahl aus UI lesen
            const itemsToProcess = [];
            for (let i = 0; i < scannerResults.length; i++) {
                const checkbox = document.getElementById(`scanner_item_${i}`);
                if (checkbox && checkbox.checked) {
                    const item = scannerResults[i];
                    // Aktuelle Werte aus UI lesen
                    const actionSelect = document.getElementById(`scanner_action_${i}`);
                    const lmSelect = document.getElementById(`scanner_lm_${i}`);
                    const katSelect = document.getElementById(`scanner_kat_${i}`);

                    item.selectedAction = actionSelect ? actionSelect.value : item.selectedAction;
                    item.selectedLmId = lmSelect && lmSelect.value && lmSelect.value !== '__all__' ? parseInt(lmSelect.value) : item.selectedLmId;
                    item.selectedKategorie = katSelect ? katSelect.value : item.selectedKategorie;

                    if (item.selectedAction !== 'skip') {
                        itemsToProcess.push(item);
                    }
                }
            }

            if (itemsToProcess.length === 0) {
                alert('‚ö†Ô∏è Keine Produkte zum Importieren ausgew√§hlt!');
                return;
            }

            let importedCount = 0;
            let updatedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;

            for (const item of itemsToProcess) {
                try {
                    if (item.selectedAction === 'new') {
                        // Neues Lebensmittel erstellen
                        const maxGastroId = Math.max(0, ...lebensmittelData.map(lm => lm.gastro_id || 0));
                        const newLm = {
                            name: item.name,
                            kategorie: item.selectedKategorie || 'Sonstige',
                            preis: item.preis_pro_einheit,
                            einheit: item.einheit || 'kg',
                            ruestverlust: 0,
                            garverlust: 0,
                            lieferant: '',
                            bemerkungen: 'Importiert aus Lieferschein-Scan',
                            gastro_id: maxGastroId + 1
                        };
                        await saveLebensmittelDirect(newLm);
                        importedCount++;

                    } else if (item.selectedAction === 'update') {
                        // Bestehendes Produkt aktualisieren
                        let targetLm = null;

                        // Zuerst pr√ºfen ob manuell zugeordnet
                        if (item.selectedLmId) {
                            targetLm = lebensmittelData.find(lm => lm.id === item.selectedLmId);
                        }
                        // Fallback auf automatisches Match
                        if (!targetLm && item.matchedLm) {
                            targetLm = item.matchedLm;
                        }

                        if (targetLm) {
                            const updatedLm = { ...targetLm, preis: item.preis_pro_einheit };
                            await updateLebensmittelDirect(updatedLm);
                            updatedCount++;
                        } else {
                            console.warn(`‚ö†Ô∏è Kein Ziel-Lebensmittel f√ºr "${item.name}" gefunden`);
                            skippedCount++;
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Import-Fehler:', error);
                    errorCount++;
                }
            }

            // Daten neu laden
            await loadLebensmittel();

            // Ergebnis anzeigen
            let message = '‚úÖ Import abgeschlossen!\n\n';
            if (importedCount > 0) message += `‚Ä¢ ${importedCount} neue Produkte hinzugef√ºgt\n`;
            if (updatedCount > 0) message += `‚Ä¢ ${updatedCount} Preise aktualisiert\n`;
            if (skippedCount > 0) message += `‚Ä¢ ${skippedCount} √ºbersprungen (kein Ziel gefunden)\n`;
            if (errorCount > 0) message += `‚Ä¢ ${errorCount} Fehler\n`;

            alert(message);
            clearScannerResults();
        }

        // Direktes Speichern ohne Modal
        async function saveLebensmittelDirect(lm) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('lebensmittel', 'readwrite');
                const store = tx.objectStore('lebensmittel');
                const request = store.add(lm);
                request.onsuccess = () => {
                    lm.id = request.result;
                    syncToFirestore('lebensmittel', lm);
                    resolve(lm);
                };
                request.onerror = () => reject(request.error);
            });
        }

        // Direktes Update ohne Modal
        async function updateLebensmittelDirect(lm) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('lebensmittel', 'readwrite');
                const store = tx.objectStore('lebensmittel');
                const request = store.put(lm);
                request.onsuccess = () => {
                    syncToFirestore('lebensmittel', lm);
                    resolve(lm);
                };
                request.onerror = () => reject(request.error);
            });
        }

        // Scanner-Ergebnisse l√∂schen
        function clearScannerResults() {
            scannerResults = [];
            document.getElementById('scannerResults').style.display = 'none';
            clearLieferscheinUpload();
        }

        // Einstellungen-Tab laden
        async function loadEinstellungenTab() {
            await loadApiKey();
            setupDragAndDrop();
        }

        function openLebensmittelModal(id = null) {
            currentEditId = id;
            const modal = document.getElementById('lebensmittelModal');
            const title = document.getElementById('lebensmittelModalTitle');

            // Reset all saison checkboxes
            const saisonMonths = ['jan', 'feb', 'mar', 'apr', 'mai', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dez'];
            saisonMonths.forEach(m => {
                const cb = document.getElementById('lm_saison_' + m);
                if (cb) cb.checked = false;
            });

            if (id) {
                title.textContent = 'Lebensmittel bearbeiten';
                const lm = lebensmittelData.find(l => l.id === id);
                document.getElementById('lm_id').value = lm.id;
                document.getElementById('lm_name').value = lm.name;
                document.getElementById('lm_kategorie').value = lm.kategorie;
                document.getElementById('lm_preis').value = lm.preis;
                document.getElementById('lm_einheit').value = lm.einheit;
                document.getElementById('lm_ruestverlust').value = lm.ruestverlust || 0;
                document.getElementById('lm_garverlust').value = lm.garverlust || 0;
                document.getElementById('lm_lieferant').value = lm.lieferant || '';
                document.getElementById('lm_bemerkungen').value = lm.bemerkungen || '';

                // Set saison checkboxes
                if (lm.saison && Array.isArray(lm.saison)) {
                    lm.saison.forEach(month => {
                        const monthId = saisonMonths[month - 1];
                        const cb = document.getElementById('lm_saison_' + monthId);
                        if (cb) cb.checked = true;
                    });
                }
            } else {
                title.textContent = 'Neues Lebensmittel';
                document.getElementById('lebensmittelForm').reset();
            }

            modal.classList.add('active');
        }

        function closeLebensmittelModal() {
            document.getElementById('lebensmittelModal').classList.remove('active');
            currentEditId = null;
        }

        async function saveLebensmittel(event) {
            event.preventDefault();

            // Collect saison months
            const saisonMonths = ['jan', 'feb', 'mar', 'apr', 'mai', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dez'];
            const selectedSaison = [];
            saisonMonths.forEach((m, index) => {
                const cb = document.getElementById('lm_saison_' + m);
                if (cb && cb.checked) {
                    selectedSaison.push(index + 1); // 1-12
                }
            });

            const data = {
                name: document.getElementById('lm_name').value,
                kategorie: document.getElementById('lm_kategorie').value,
                preis: parseFloat(document.getElementById('lm_preis').value),
                einheit: document.getElementById('lm_einheit').value,
                ruestverlust: parseFloat(document.getElementById('lm_ruestverlust').value) || 0,
                garverlust: parseFloat(document.getElementById('lm_garverlust').value) || 0,
                lieferant: document.getElementById('lm_lieferant').value,
                bemerkungen: document.getElementById('lm_bemerkungen').value,
                saison: selectedSaison.length > 0 ? selectedSaison : null // null = ganzj√§hrig
            };

            // FIX: Auto-Vergabe gastro_id f√ºr korrekte Rezept-Zuordnung
            if (currentEditId) {
                // Bearbeiten: gastro_id vom bestehenden Lebensmittel √ºbernehmen
                const existing = lebensmittelData.find(lm => lm.id === currentEditId);
                data.gastro_id = existing ? existing.gastro_id : null;
                await updateLebensmittel(currentEditId, data);
            } else {
                // Neu: Automatische gastro_id Vergabe (h√∂chste bestehende + 1)
                const maxGastroId = lebensmittelData.reduce((max, lm) => {
                    return (lm.gastro_id && lm.gastro_id > max) ? lm.gastro_id : max;
                }, 280); // Start nach h√∂chster GASTRO_DATENBANK ID (280)

                data.gastro_id = maxGastroId + 1;
                await addLebensmittel(data);
            }

            closeLebensmittelModal();
            await loadLebensmittel();
        }

        function editLebensmittel(id) {
            openLebensmittelModal(id);
        }

        async function confirmDeleteLebensmittel(id) {
            if (confirm('Lebensmittel wirklich l√∂schen?')) {
                await deleteLebensmittel(id);
                await loadLebensmittel();
            }
        }

        // ===== REZEPTE FUNCTIONS =====
        async function loadRezepte() {
            rezepteData = await getAllRezepte();
            renderRezepteTable(rezepteData);
            updateStats();
        }

        function renderRezepteTable(data) {
            const container = document.getElementById('rezepteTable');

            if (data.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìñ</div>
                        <div class="empty-state-text">Noch keine Rezepte vorhanden</div>
                        <button class="btn btn-primary" onclick="openRezeptModal()">
                            ‚ûï Erstes Rezept hinzuf√ºgen
                        </button>
                    </div>
                `;
                return;
            }

            let html = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Kategorie</th>
                            <th>Portionen</th>
                            <th>Verkaufspreis</th>
                            <th>Wareneinsatz</th>
                            <th>Food Cost</th>
                            <th>Aktionen</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            data.forEach(rz => {
                const wareneinsatz = calculateRezeptWareneinsatz(rz);
                const foodCost = (wareneinsatz / rz.verkaufspreis * 100).toFixed(1);
                const foodCostClass = foodCost < 30 ? 'excellent' : foodCost < 35 ? 'good' : 'warning';

                html += `
                    <tr>
                        <td><strong>${rz.name}</strong></td>
                        <td><span class="badge badge-info">${rz.kategorie}</span></td>
                        <td>${rz.portionen}</td>
                        <td>CHF ${rz.verkaufspreis.toFixed(2)}</td>
                        <td>CHF ${wareneinsatz.toFixed(2)}</td>
                        <td><span class="food-cost-indicator food-cost-${foodCostClass}">${foodCost}%</span></td>
                        <td class="action-buttons">
                            <button class="btn-icon" onclick="viewRezept(${rz.id})" title="Details">üëÅÔ∏è</button>
                            <button class="btn-icon" onclick="editRezept(${rz.id})" title="Bearbeiten">‚úèÔ∏è</button>
                            <button class="btn-icon delete" onclick="confirmDeleteRezept(${rz.id})" title="L√∂schen">üóëÔ∏è</button>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function calculateRezeptWareneinsatz(rezept) {
            if (!rezept.zutaten) return 0;

            let total = 0;
            rezept.zutaten.forEach(zutat => {
                // KORREKTUR: Rezepte verwenden produkt_id (nicht lebensmittel_id) und matchen gegen gastro_id
                const lm = lebensmittelData.find(l => l.gastro_id === zutat.produkt_id);
                if (!lm) return;

                let menge = zutat.menge;

                // R√ºstverlust anwenden
                if (lm.ruestverlust > 0) {
                    menge = menge / (1 - lm.ruestverlust / 100);
                }

                // Garverlust anwenden
                if (lm.garverlust > 0) {
                    menge = menge / (1 - lm.garverlust / 100);
                }

                // Preis berechnen (Preis ist pro kg/L, Menge in g/ml)
                const faktor = lm.einheit === 'Stk' ? 1 : 1000;
                total += (menge / faktor) * lm.preis;
            });

            return total;
        }

        function searchRezepte() {
            const query = document.getElementById('searchRezepte').value.toLowerCase();
            const filtered = rezepteData.filter(rz =>
                rz.name.toLowerCase().includes(query) ||
                rz.kategorie.toLowerCase().includes(query)
            );
            renderRezepteTable(filtered);
        }

        function filterRezepte() {
            const kategorie = document.getElementById('filterRezeptKategorie').value;
            if (!kategorie) {
                renderRezepteTable(rezepteData);
                return;
            }
            const filtered = rezepteData.filter(rz => rz.kategorie === kategorie);
            renderRezepteTable(filtered);
        }

        // ===== MEN√úKARTEN LADEN =====

        async function loadMenuekarten() {
            menuekartenData = await getAllMenuekarten();
            updateStats();
        }

        // ===== REZEPT-MODAL =====

        function openRezeptModal(id = null) {
            currentEditId = id;
            const modal = document.getElementById('rezeptModal');
            const title = document.getElementById('rezeptModalTitle');

            if (id) {
                title.textContent = 'Rezept bearbeiten';
                const rz = rezepteData.find(r => r.id === id);
                document.getElementById('rz_id').value = rz.id;
                document.getElementById('rz_name').value = rz.name;
                document.getElementById('rz_kategorie').value = rz.kategorie;
                document.getElementById('rz_portionen').value = rz.portionen;
                document.getElementById('rz_verkaufspreis').value = rz.verkaufspreis;
                document.getElementById('rz_beschreibung').value = rz.beschreibung || '';

                // Zutaten laden
                const container = document.getElementById('rzZutatenContainer');
                container.innerHTML = '';
                if (rz.zutaten) {
                    rz.zutaten.forEach((zutat, index) => {
                        addRezeptZutat(zutat);
                    });
                }

                // Zubereitungsschritte laden
                const zubereitungContainer = document.getElementById('rzZubereitungContainer');
                zubereitungContainer.innerHTML = '';
                if (rz.zubereitung && rz.zubereitung.length > 0) {
                    rz.zubereitung.forEach(schritt => {
                        addZubereitungsSchritt(schritt);
                    });
                }

                // Zusatzinformationen laden
                document.getElementById('rz_allergene').value = rz.allergene ? rz.allergene.join(', ') : '';
                document.getElementById('rz_zubereitungszeit').value = rz.zubereitungszeit || '';
                document.getElementById('rz_schwierigkeit').value = rz.schwierigkeit || '';
                document.getElementById('rz_quelle').value = rz.quelle || '';
                document.getElementById('rz_bemerkung').value = rz.bemerkung || '';
            } else {
                title.textContent = 'Neues Rezept';
                document.getElementById('rezeptForm').reset();
                document.getElementById('rzZutatenContainer').innerHTML = '';
                document.getElementById('rzZubereitungContainer').innerHTML = '';
                addRezeptZutat(); // Eine leere Zutat
            }

            modal.classList.add('active');
        }

        function closeRezeptModal() {
            document.getElementById('rezeptModal').classList.remove('active');
            currentEditId = null;
        }

        // ===== AUTOCOMPLETE COMPONENT =====

        /**
         * Erstellt ein Autocomplete-Textfeld f√ºr Lebensmittel-Auswahl
         * @param {string} containerId - ID des Containers
         * @param {number|null} selectedGastroId - Bereits ausgew√§hlte gastro_id (f√ºr Edit-Modus)
         * @returns {HTMLElement} Container mit Autocomplete-Feld
         */
        function createAutocompleteField(containerId, selectedGastroId = null) {
            const container = document.createElement('div');
            container.className = 'autocomplete-container';
            container.id = containerId;

            // Hidden Input f√ºr gastro_id (wird an Backend/Speicherung √ºbergeben)
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.className = 'zutat-select';
            hiddenInput.value = selectedGastroId || '';

            // Visible Input f√ºr User-Interaktion
            const visibleInput = document.createElement('input');
            visibleInput.type = 'text';
            visibleInput.className = 'autocomplete-input';
            visibleInput.placeholder = 'Zutat suchen... (z.B. Kalbshaxe, Zwiebeln)';
            visibleInput.autocomplete = 'off';

            // Dropdown f√ºr Ergebnisse
            const dropdown = document.createElement('div');
            dropdown.className = 'autocomplete-dropdown';

            // Wenn bereits ausgew√§hlt, zeige Lebensmittel-Name an
            if (selectedGastroId) {
                const selectedItem = lebensmittelData.find(lm => lm.gastro_id === selectedGastroId);
                if (selectedItem) {
                    visibleInput.value = selectedItem.name;
                    visibleInput.classList.add('has-selection');
                }
            }

            // State Management
            let currentFocus = -1;
            let filteredResults = [];

            // FUNKTION: Filtern und Sortieren
            function filterLebensmittel(query) {
                if (!query || query.length < 1) return [];

                const lowerQuery = query.toLowerCase();
                const results = lebensmittelData.filter(lm => {
                    const nameMatch = lm.name.toLowerCase().includes(lowerQuery);
                    const kategorieMatch = lm.kategorie.toLowerCase().includes(lowerQuery);
                    return nameMatch || kategorieMatch;
                });

                // Sortieren nach Relevanz (Exakte Treffer zuerst, dann Starts-With, dann Contains)
                results.sort((a, b) => {
                    const aName = a.name.toLowerCase();
                    const bName = b.name.toLowerCase();

                    // Exakter Match
                    if (aName === lowerQuery) return -1;
                    if (bName === lowerQuery) return 1;

                    // Starts with
                    const aStarts = aName.startsWith(lowerQuery);
                    const bStarts = bName.startsWith(lowerQuery);
                    if (aStarts && !bStarts) return -1;
                    if (!aStarts && bStarts) return 1;

                    // Alphabetisch
                    return aName.localeCompare(bName);
                });

                // Max 15 Ergebnisse (Performance)
                return results.slice(0, 15);
            }

            // FUNKTION: Dropdown rendern
            function renderDropdown(results) {
                dropdown.innerHTML = '';

                if (results.length === 0) {
                    dropdown.innerHTML = '<div class="autocomplete-no-results">Keine Lebensmittel gefunden</div>';
                    dropdown.classList.add('active');
                    return;
                }

                results.forEach((lm, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.dataset.index = index;
                    item.dataset.gastroId = lm.gastro_id;

                    item.innerHTML = `
                        <span class="autocomplete-item-name">${lm.name}</span>
                        <span class="autocomplete-item-category">(${lm.kategorie})</span>
                    `;

                    // Click Event
                    item.addEventListener('click', () => selectItem(lm));

                    dropdown.appendChild(item);
                });

                dropdown.classList.add('active');
                currentFocus = -1;
            }

            // FUNKTION: Item ausw√§hlen
            function selectItem(lebensmittel) {
                hiddenInput.value = lebensmittel.gastro_id;
                visibleInput.value = lebensmittel.name;
                visibleInput.classList.add('has-selection');
                dropdown.classList.remove('active');
                dropdown.innerHTML = '';
            }

            // FUNKTION: Dropdown schlie√üen
            function closeDropdown() {
                dropdown.classList.remove('active');
                dropdown.innerHTML = '';
                currentFocus = -1;
            }

            // FUNKTION: Keyboard-Navigation (Pfeiltasten)
            function setActiveFocus(index) {
                const items = dropdown.querySelectorAll('.autocomplete-item');
                items.forEach(item => item.classList.remove('selected'));

                if (index >= 0 && index < items.length) {
                    items[index].classList.add('selected');
                    items[index].scrollIntoView({ block: 'nearest' });
                }
            }

            // EVENT: Input-√Ñnderung
            visibleInput.addEventListener('input', (e) => {
                const query = e.target.value;

                // Wenn User l√∂scht, reset Selection
                if (query === '') {
                    hiddenInput.value = '';
                    visibleInput.classList.remove('has-selection');
                    closeDropdown();
                    return;
                }

                // Bei √Ñnderung nach Selection, remove green background
                if (hiddenInput.value) {
                    hiddenInput.value = '';
                    visibleInput.classList.remove('has-selection');
                }

                // Filtern und Rendern
                filteredResults = filterLebensmittel(query);
                renderDropdown(filteredResults);
            });

            // EVENT: Keyboard-Navigation (Pfeiltasten, Enter, Escape)
            visibleInput.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.autocomplete-item');

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentFocus++;
                    if (currentFocus >= items.length) currentFocus = 0;
                    setActiveFocus(currentFocus);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentFocus--;
                    if (currentFocus < 0) currentFocus = items.length - 1;
                    setActiveFocus(currentFocus);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentFocus >= 0 && currentFocus < filteredResults.length) {
                        selectItem(filteredResults[currentFocus]);
                    }
                } else if (e.key === 'Escape') {
                    closeDropdown();
                }
            });

            // EVENT: Click outside schlie√üt Dropdown
            document.addEventListener('click', (e) => {
                if (!container.contains(e.target)) {
                    closeDropdown();
                }
            });

            // Assembly
            container.appendChild(hiddenInput);
            container.appendChild(visibleInput);
            container.appendChild(dropdown);

            return container;
        }

        function addRezeptZutat(zutat = null) {
            const container = document.getElementById('rzZutatenContainer');
            const index = container.children.length;

            const row = document.createElement('div');
            row.className = 'form-row';
            row.style.marginBottom = '1rem';
            row.style.position = 'relative';

            // === AUTOCOMPLETE STATT DROPDOWN ===
            // Create form-group for autocomplete
            const autocompleteFormGroup = document.createElement('div');
            autocompleteFormGroup.className = 'form-group';
            autocompleteFormGroup.style.flex = '2';

            // Create autocomplete field (selectedGastroId = zutat.produkt_id im Edit-Modus)
            const autocomplete = createAutocompleteField(
                `autocomplete-${index}`,
                zutat ? zutat.produkt_id : null
            );
            autocompleteFormGroup.appendChild(autocomplete);

            // Create form-group for Menge
            const mengeFormGroup = document.createElement('div');
            mengeFormGroup.className = 'form-group';
            mengeFormGroup.style.flex = '1';
            const mengeInput = document.createElement('input');
            mengeInput.type = 'number';
            mengeInput.className = 'form-input zutat-menge';
            mengeInput.placeholder = 'Menge';
            mengeInput.value = zutat ? zutat.menge : '';
            mengeInput.step = '0.1';
            mengeInput.required = true;
            mengeFormGroup.appendChild(mengeInput);

            // Create form-group for Einheit
            const einheitFormGroup = document.createElement('div');
            einheitFormGroup.className = 'form-group';
            einheitFormGroup.style.flex = '1';
            const einheitSelect = document.createElement('select');
            einheitSelect.className = 'form-select zutat-einheit';
            einheitSelect.required = true;
            einheitSelect.innerHTML = `
                <option value="g" ${zutat && zutat.einheit === 'g' ? 'selected' : ''}>g</option>
                <option value="ml" ${zutat && zutat.einheit === 'ml' ? 'selected' : ''}>ml</option>
                <option value="Stk" ${zutat && zutat.einheit === 'Stk' ? 'selected' : ''}>Stk</option>
            `;
            einheitFormGroup.appendChild(einheitSelect);

            // Create delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'btn-icon delete';
            deleteBtn.textContent = 'üóëÔ∏è';
            deleteBtn.style.position = 'absolute';
            deleteBtn.style.right = '-40px';
            deleteBtn.style.top = '50%';
            deleteBtn.style.transform = 'translateY(-50%)';
            deleteBtn.onclick = function () {
                this.parentElement.remove();
            };

            // Assembly
            row.appendChild(autocompleteFormGroup);
            row.appendChild(mengeFormGroup);
            row.appendChild(einheitFormGroup);
            row.appendChild(deleteBtn);

            container.appendChild(row);
        }

        async function saveRezept(event) {
            event.preventDefault();

            // Zutaten sammeln
            const zutaten = [];
            const zutatenRows = document.getElementById('rzZutatenContainer').children;

            for (let row of zutatenRows) {
                const lm_id = parseInt(row.querySelector('.zutat-select').value);
                const menge = parseFloat(row.querySelector('.zutat-menge').value);
                const einheit = row.querySelector('.zutat-einheit').value;

                if (lm_id && menge) {
                    // KORREKTUR: Speichere als produkt_id (nicht lebensmittel_id) f√ºr konsistentes Mapping
                    zutaten.push({
                        produkt_id: lm_id, // lm_id ist jetzt gastro_id vom Dropdown
                        menge: menge,
                        einheit: einheit
                    });
                }
            }

            // Zubereitungsschritte sammeln
            const zubereitungsSchritte = Array.from(document.querySelectorAll('.rz-zubereitung-schritt'))
                .map(textarea => textarea.value.trim())
                .filter(text => text.length > 0);

            // Allergene sammeln (kommagetrennt)
            const allergeneInput = document.getElementById('rz_allergene').value;
            const allergene = allergeneInput
                ? allergeneInput.split(',').map(a => a.trim()).filter(a => a.length > 0)
                : [];

            const data = {
                name: document.getElementById('rz_name').value,
                kategorie: document.getElementById('rz_kategorie').value,
                portionen: parseInt(document.getElementById('rz_portionen').value),
                verkaufspreis: parseFloat(document.getElementById('rz_verkaufspreis').value),
                beschreibung: document.getElementById('rz_beschreibung').value,
                zutaten: zutaten,
                // Neue Felder
                zubereitung: zubereitungsSchritte,
                allergene: allergene,
                zubereitungszeit: document.getElementById('rz_zubereitungszeit').value || null,
                schwierigkeit: document.getElementById('rz_schwierigkeit').value || null,
                quelle: document.getElementById('rz_quelle').value || null,
                bemerkung: document.getElementById('rz_bemerkung').value || null
            };

            if (currentEditId) {
                // FIX: Bestehendes Rezept laden und mit neuen Daten mergen
                // Verhindert Verlust von Feldern die nicht im Formular sind
                // (zubereitungszeit, schwierigkeit, zubereitung, quelle, bemerkung)
                const existingRezept = rezepteData.find(r => r.id === currentEditId);

                const mergedData = {
                    ...existingRezept,     // Alle bestehenden Felder erhalten
                    ...data,               // Formular-Daten √ºberschreiben
                    id: currentEditId      // ID explizit setzen
                };

                await updateRezept(currentEditId, mergedData);
            } else {
                await addRezept(data);
            }

            closeRezeptModal();
            await loadRezepte();
        }

        function editRezept(id) {
            openRezeptModal(id);
        }

        async function confirmDeleteRezept(id) {
            if (confirm('Rezept wirklich l√∂schen?')) {
                await deleteRezept(id);
                await loadRezepte();
            }
        }

        function viewRezept(id) {
            const rezept = rezepteData.find(r => r.id === id);
            if (!rezept) return;

            const wareneinsatz = calculateRezeptWareneinsatz(rezept);
            const foodCost = rezept.verkaufspreis > 0
                ? (wareneinsatz / rezept.verkaufspreis * 100).toFixed(1)
                : '0.0';

            // Fill Modal Header
            document.getElementById('modalRezeptName').textContent = rezept.name;

            // Meta Information
            const metaHtml = `
                <div class="rezept-modal-meta-item">
                    <strong>üìÅ Kategorie:</strong> ${rezept.kategorie}
                </div>
                <div class="rezept-modal-meta-item">
                    <strong>üë• Portionen:</strong> ${rezept.portionen}
                </div>
                <div class="rezept-modal-meta-item">
                    <strong>üí∞ Verkaufspreis:</strong> CHF ${rezept.verkaufspreis.toFixed(2)}
                </div>
            `;
            document.getElementById('modalRezeptMeta').innerHTML = metaHtml;

            // Cost Summary with color coding
            let foodCostClass = 'good';
            if (parseFloat(foodCost) > 35) foodCostClass = 'warning';
            if (parseFloat(foodCost) > 40) foodCostClass = 'danger';

            const costSummaryHtml = `
                <div class="rezept-cost-item">
                    <div class="rezept-cost-value">CHF ${wareneinsatz.toFixed(2)}</div>
                    <div class="rezept-cost-label">Wareneinsatz</div>
                </div>
                <div class="rezept-cost-item">
                    <div class="rezept-cost-value ${foodCostClass}">${foodCost}%</div>
                    <div class="rezept-cost-label">Food Cost</div>
                </div>
                <div class="rezept-cost-item">
                    <div class="rezept-cost-value">CHF ${(rezept.verkaufspreis - wareneinsatz).toFixed(2)}</div>
                    <div class="rezept-cost-label">Marge</div>
                </div>
                <div class="rezept-cost-item">
                    <div class="rezept-cost-value">CHF ${(rezept.verkaufspreis / rezept.portionen).toFixed(2)}</div>
                    <div class="rezept-cost-label">Preis/Portion</div>
                </div>
            `;
            document.getElementById('modalCostSummary').innerHTML = costSummaryHtml;

            // Zutaten List
            let zutatenHtml = '';
            if (rezept.zutaten && rezept.zutaten.length > 0) {
                rezept.zutaten.forEach(zutat => {
                    const lm = lebensmittelData.find(l => l.gastro_id === zutat.produkt_id);
                    if (lm) {
                        const einzelpreis = (lm.preis_pro_einheit * zutat.menge).toFixed(2);
                        zutatenHtml += `
                            <div class="rezept-zutat-item">
                                <span class="rezept-zutat-name">${lm.name}</span>
                                <span class="rezept-zutat-menge">${zutat.menge}${zutat.einheit} (CHF ${einzelpreis})</span>
                            </div>
                        `;
                    } else {
                        zutatenHtml += `
                            <div class="rezept-zutat-item">
                                <span class="rezept-zutat-name">‚ö†Ô∏è Unbekanntes Produkt (ID: ${zutat.produkt_id})</span>
                                <span class="rezept-zutat-menge">${zutat.menge}${zutat.einheit}</span>
                            </div>
                        `;
                    }
                });
            } else {
                zutatenHtml = '<p style="opacity: 0.6;">Keine Zutaten definiert.</p>';
            }
            document.getElementById('modalZutatenList').innerHTML = zutatenHtml;

            // Zubereitung
            if (rezept.zubereitung && rezept.zubereitung.length > 0) {
                let zubereitungHtml = '';
                rezept.zubereitung.forEach(schritt => {
                    zubereitungHtml += `<li>${schritt}</li>`;
                });
                document.getElementById('modalZubereitungList').innerHTML = zubereitungHtml;
                document.getElementById('modalZubereitungSection').style.display = 'block';
            } else {
                document.getElementById('modalZubereitungSection').style.display = 'none';
            }

            // Bemerkung
            if (rezept.bemerkung) {
                document.getElementById('modalBemerkung').textContent = rezept.bemerkung;
                document.getElementById('modalBemerkungSection').style.display = 'block';
            } else {
                document.getElementById('modalBemerkungSection').style.display = 'none';
            }

            // Quelle
            let quelleHtml = '';
            if (rezept.quelle) {
                if (rezept.quelle.startsWith('http')) {
                    quelleHtml = `<strong>üìö Quelle:</strong> <a href="${rezept.quelle}" target="_blank" rel="noopener">${rezept.quelle}</a>`;
                } else {
                    quelleHtml = `<strong>üìö Quelle:</strong> ${rezept.quelle}`;
                }
            } else {
                quelleHtml = '<em>Keine Quelle angegeben</em>';
            }
            document.getElementById('modalQuelle').innerHTML = quelleHtml;

            // Show Modal
            document.getElementById('rezeptModal').classList.add('active');
        }

        function closeRezeptDetailModal() {
            document.getElementById('rezeptModal').classList.remove('active');
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('rezeptModal');
            if (e.target === modal) {
                closeRezeptDetailModal();
            }
        });

        // ===== KALKULATION FUNCTIONS =====
        function loadKalkulationTab() {
            const select = document.getElementById('calcRezeptSelect');
            select.innerHTML = '<option value="">-- Rezept w√§hlen --</option>';

            rezepteData.forEach(rz => {
                select.innerHTML += `<option value="${rz.id}">${rz.name} (${rz.kategorie})</option>`;
            });
        }

        function loadRezeptForCalculation() {
            const rezeptId = parseInt(document.getElementById('calcRezeptSelect').value);
            if (!rezeptId) {
                document.getElementById('calcDetails').innerHTML = '';
                document.getElementById('calcResult').innerHTML = '';
                return;
            }

            const rezept = rezepteData.find(r => r.id === rezeptId);
            if (!rezept) return;

            document.getElementById('calcPersonen').value = rezept.portionen;
            document.getElementById('calcVerkaufspreis').value = rezept.verkaufspreis;

            recalculate();
        }

        function recalculate() {
            const rezeptId = parseInt(document.getElementById('calcRezeptSelect').value);
            if (!rezeptId) return;

            const rezept = rezepteData.find(r => r.id === rezeptId);
            const personen = parseInt(document.getElementById('calcPersonen').value);
            const verkaufspreis = parseFloat(document.getElementById('calcVerkaufspreis').value);

            const faktor = personen / rezept.portionen;

            // Zutaten-Details
            let detailsHtml = '<h3 style="margin-top: 2rem;">Zutaten-Liste (skaliert)</h3>';
            detailsHtml += '<table class="data-table"><thead><tr><th>Zutat</th><th>Menge</th><th>Einheit</th><th>R√ºstverlust</th><th>Garverlust</th><th>Brutto-Menge</th><th>Wareneinsatz</th></tr></thead><tbody>';

            let totalWareneinsatz = 0;

            if (rezept.zutaten) {
                rezept.zutaten.forEach(zutat => {
                    // KORREKTUR: Rezepte verwenden produkt_id (nicht lebensmittel_id) und matchen gegen gastro_id
                    const lm = lebensmittelData.find(l => l.gastro_id === zutat.produkt_id);
                    if (!lm) return;

                    const nettoMenge = zutat.menge * faktor;
                    let bruttoMenge = nettoMenge;

                    // Verluste
                    if (lm.ruestverlust > 0) {
                        bruttoMenge = bruttoMenge / (1 - lm.ruestverlust / 100);
                    }
                    if (lm.garverlust > 0) {
                        bruttoMenge = bruttoMenge / (1 - lm.garverlust / 100);
                    }

                    const preisFaktor = lm.einheit === 'Stk' ? 1 : 1000;
                    const wareneinsatz = (bruttoMenge / preisFaktor) * lm.preis;
                    totalWareneinsatz += wareneinsatz;

                    detailsHtml += `
                        <tr>
                            <td><strong>${lm.name}</strong></td>
                            <td>${nettoMenge.toFixed(1)}</td>
                            <td>${zutat.einheit}</td>
                            <td>${lm.ruestverlust || 0}%</td>
                            <td>${lm.garverlust || 0}%</td>
                            <td>${bruttoMenge.toFixed(1)} ${zutat.einheit}</td>
                            <td>CHF ${wareneinsatz.toFixed(2)}</td>
                        </tr>
                    `;
                });
            }

            detailsHtml += '</tbody></table>';
            document.getElementById('calcDetails').innerHTML = detailsHtml;

            // Ergebnis
            const totalVerkaufspreis = verkaufspreis * personen;
            const foodCost = (totalWareneinsatz / totalVerkaufspreis * 100).toFixed(1);
            const deckungsbeitrag = totalVerkaufspreis - totalWareneinsatz;
            const foodCostClass = foodCost < 30 ? 'excellent' : foodCost < 35 ? 'good' : 'warning';

            const resultHtml = `
                <div class="calc-result">
                    <h3>Kalkulations-Ergebnis</h3>
                    <div class="calc-result-grid">
                        <div class="calc-result-item">
                            <div class="calc-result-value">${personen}</div>
                            <div class="calc-result-label">Personen</div>
                        </div>
                        <div class="calc-result-item">
                            <div class="calc-result-value">CHF ${totalWareneinsatz.toFixed(2)}</div>
                            <div class="calc-result-label">Wareneinsatz Total</div>
                        </div>
                        <div class="calc-result-item">
                            <div class="calc-result-value">CHF ${totalVerkaufspreis.toFixed(2)}</div>
                            <div class="calc-result-label">Verkaufspreis Total</div>
                        </div>
                        <div class="calc-result-item">
                            <div class="calc-result-value">${foodCost}%</div>
                            <div class="calc-result-label">Food Cost</div>
                        </div>
                        <div class="calc-result-item">
                            <div class="calc-result-value">CHF ${deckungsbeitrag.toFixed(2)}</div>
                            <div class="calc-result-label">Deckungsbeitrag</div>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('calcResult').innerHTML = resultHtml;
        }

        function exportCalcPDF() {
            alert('PDF-Export wird in K√ºrze implementiert!');
        }

        function saveCalculation() {
            alert('Kalkulation gespeichert! (wird im LocalStorage abgelegt)');
        }

        // ===== EINKAUFSLISTE FUNCTIONS =====
        function loadEinkaufslisteTab() {
            const container = document.getElementById('einkaufslisteRezepte');
            container.innerHTML = '';

            rezepteData.forEach(rz => {
                const checkbox = document.createElement('div');
                checkbox.style.marginBottom = '0.75rem';
                checkbox.innerHTML = `
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" value="${rz.id}" class="einkaufsliste-checkbox">
                        <strong>${rz.name}</strong> (${rz.kategorie}) - ${rz.portionen} Portionen
                    </label>
                `;
                container.appendChild(checkbox);
            });
        }

        function generateEinkaufsliste() {
            const checkboxes = document.querySelectorAll('.einkaufsliste-checkbox:checked');
            if (checkboxes.length === 0) {
                alert('Bitte mindestens ein Rezept ausw√§hlen!');
                return;
            }

            const zutatSummary = {};

            checkboxes.forEach(cb => {
                const rezeptId = parseInt(cb.value);
                const rezept = rezepteData.find(r => r.id === rezeptId);

                if (rezept && rezept.zutaten) {
                    rezept.zutaten.forEach(zutat => {
                        // KORREKTUR: Verwende gastro_id und produkt_id f√ºr konsistentes Mapping
                        const lm = lebensmittelData.find(l => l.gastro_id === zutat.produkt_id);
                        if (!lm) return;

                        const key = `${lm.gastro_id}-${zutat.einheit}`;

                        if (!zutatSummary[key]) {
                            zutatSummary[key] = {
                                name: lm.name,
                                kategorie: lm.kategorie,
                                menge: 0,
                                einheit: zutat.einheit,
                                lieferant: lm.lieferant
                            };
                        }

                        zutatSummary[key].menge += zutat.menge;
                    });
                }
            });

            // Nach Kategorie gruppieren
            const byKategorie = {};
            Object.values(zutatSummary).forEach(item => {
                if (!byKategorie[item.kategorie]) {
                    byKategorie[item.kategorie] = [];
                }
                byKategorie[item.kategorie].push(item);
            });

            // Rendern
            let html = '<h3 style="margin-top: 2rem;">Einkaufsliste</h3>';

            Object.keys(byKategorie).sort().forEach(kategorie => {
                html += `<h4 style="margin-top: 1.5rem; color: var(--dakota-gold);">${kategorie}</h4>`;
                html += '<table class="data-table"><thead><tr><th>Zutat</th><th>Menge</th><th>Einheit</th><th>Lieferant</th></tr></thead><tbody>';

                byKategorie[kategorie].forEach(item => {
                    html += `
                        <tr>
                            <td><strong>${item.name}</strong></td>
                            <td>${item.menge.toFixed(1)}</td>
                            <td>${item.einheit}</td>
                            <td>${item.lieferant || '-'}</td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
            });

            document.getElementById('einkaufslisteResult').innerHTML = html;
        }

        function exportEinkaufslistePDF() {
            alert('PDF-Export wird in K√ºrze implementiert!');
        }

        function printEinkaufsliste() {
            window.print();
        }

        // ===== STATS UPDATE =====
        function updateStats() {
            document.getElementById('totalLebensmittel').textContent = lebensmittelData.length;
            document.getElementById('totalRezepte').textContent = rezepteData.length;

            if (rezepteData.length > 0) {
                const avgFoodCost = rezepteData.reduce((sum, rz) => {
                    const wareneinsatz = calculateRezeptWareneinsatz(rz);
                    return sum + (wareneinsatz / rz.verkaufspreis * 100);
                }, 0) / rezepteData.length;
                document.getElementById('avgFoodCost').textContent = avgFoodCost.toFixed(1) + '%';
            }
        }

        // ===== BEISPIEL-DATEN HINZUF√úGEN =====
        async function addExampleData() {
            // Beispiel-Lebensmittel
            const exampleLM = [
                { name: 'Alpk√§se', kategorie: 'K√§se', preis: 28.00, einheit: 'kg', ruestverlust: 0, garverlust: 0, lieferant: 'Alpk√§serei Engstlenalp' },
                { name: 'Rindsfilet', kategorie: 'Fleisch', preis: 65.00, einheit: 'kg', ruestverlust: 5, garverlust: 25, lieferant: 'Metzgerei Trachsel' },
                { name: 'Kartoffeln', kategorie: 'Gem√ºse', preis: 3.00, einheit: 'kg', ruestverlust: 15, garverlust: 5, lieferant: 'Bio-Hof Hasliberg' },
                { name: 'Rahm', kategorie: 'Milchprodukte', preis: 8.00, einheit: 'L', ruestverlust: 0, garverlust: 0, lieferant: 'K√§serei Meiringen' },
                { name: 'Butter', kategorie: 'Milchprodukte', preis: 16.00, einheit: 'kg', ruestverlust: 0, garverlust: 0, lieferant: 'K√§serei Meiringen' }
            ];

            for (let lm of exampleLM) {
                await addLebensmittel(lm);
            }

            await loadLebensmittel();

            alert('Beispiel-Daten hinzugef√ºgt! üéâ');
        }

        // ===== MEN√úKARTEN FUNCTIONS =====
        async function loadMenuekartenTab() {
            // FIX: Sicherstellen dass Rezepte geladen sind, bevor Dropdown populiert wird
            if (rezepteData.length === 0) {
                console.log('üìã Lade Rezepte f√ºr Men√ºkarten-Dropdown...');
                await loadRezepte();
            }

            menuekartenData = await getAllMenuekarten();
            populateMenuekartenRezeptDropdown();
            renderMenuekartenTable(menuekartenData);
        }

        function populateMenuekartenRezeptDropdown() {
            const select = document.getElementById('mk_rezept_select');
            if (!select) {
                console.warn('‚ö†Ô∏è Dropdown-Element "mk_rezept_select" nicht gefunden!');
                return;
            }

            console.log(`üìã Populiere Dropdown mit ${rezepteData.length} Rezepten`);

            select.innerHTML = '<option value="">-- Rezept ausw√§hlen --</option>';

            // Gruppiert nach Kategorie
            const kategorien = {};
            rezepteData.forEach(rz => {
                if (!kategorien[rz.kategorie]) kategorien[rz.kategorie] = [];
                kategorien[rz.kategorie].push(rz);
            });

            Object.keys(kategorien).sort().forEach(kategorie => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = kategorie;
                kategorien[kategorie].forEach(rz => {
                    const option = document.createElement('option');
                    option.value = rz.id;
                    option.textContent = `${rz.name} (CHF ${rz.verkaufspreis.toFixed(2)})`;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            });

            console.log(`‚úÖ Dropdown erfolgreich gef√ºllt: ${Object.keys(kategorien).length} Kategorien`);
        }

        function renderMenuekartenTable(data) {
            const container = document.getElementById('menuekartenTable');
            if (!container) return;

            if (data.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üçΩÔ∏è</div>
                        <div class="empty-state-text">Noch keine Men√ºkarten erstellt</div>
                        <button class="btn btn-primary" onclick="openMenuekartenModal()">
                            ‚ûï Erste Men√ºkarte erstellen
                        </button>
                    </div>
                `;
                return;
            }

            let html = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Kartenname</th>
                            <th>Typ</th>
                            <th>Anzahl Gerichte</th>
                            <th>√ò Food Cost</th>
                            <th>√ò Preis</th>
                            <th>Status</th>
                            <th>Erstellt</th>
                            <th>Aktionen</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            data.forEach(mk => {
                const gerichteCount = mk.gerichte ? mk.gerichte.length : 0;

                // Food Cost & Preis berechnen
                let avgFoodCost = 0;
                let avgPreis = 0;

                if (mk.gerichte && mk.gerichte.length > 0) {
                    let totalFoodCost = 0;
                    let totalPreis = 0;

                    mk.gerichte.forEach(gericht => {
                        const rezept = rezepteData.find(r => r.id === gericht.rezept_id);
                        if (rezept) {
                            const wareneinsatz = calculateRezeptWareneinsatz(rezept);
                            totalFoodCost += (wareneinsatz / rezept.verkaufspreis * 100);
                            totalPreis += rezept.verkaufspreis;
                        }
                    });

                    avgFoodCost = (totalFoodCost / mk.gerichte.length).toFixed(1);
                    avgPreis = (totalPreis / mk.gerichte.length).toFixed(2);
                }

                const foodCostClass = avgFoodCost < 30 ? 'success' : avgFoodCost < 35 ? 'warning' : 'danger';
                const statusBadge = mk.aktiv
                    ? '<span class="badge badge-success">Aktiv</span>'
                    : '<span class="badge badge-secondary">Inaktiv</span>';

                const typ = mk.typ === 'abendkarte' ? 'üåô Abendkarte' : '‚òÄÔ∏è Mittagsmen√º';

                html += `
                    <tr>
                        <td><strong>${mk.name}</strong></td>
                        <td>${typ}</td>
                        <td>${gerichteCount}</td>
                        <td><span class="badge badge-${foodCostClass}">${avgFoodCost}%</span></td>
                        <td>CHF ${avgPreis}</td>
                        <td>${statusBadge}</td>
                        <td>${new Date(mk.datum_erstellt).toLocaleDateString('de-CH')}</td>
                        <td>
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="btn-icon" onclick="viewMenuekarte(${mk.id})" title="Ansehen">üëÅÔ∏è</button>
                                <button class="btn-icon edit" onclick="openMenuekartenModal(${mk.id})" title="Bearbeiten">‚úèÔ∏è</button>
                                <button class="btn-icon delete" onclick="deleteMenuekarteConfirm(${mk.id})" title="L√∂schen">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function openMenuekartenModal(id = null) {
            currentEditId = id;
            const modal = document.getElementById('menuekarteModal');
            const title = document.getElementById('menuekarteModalTitle');

            populateMenuekartenRezeptDropdown();

            if (id) {
                title.textContent = 'Men√ºkarte bearbeiten';
                const mk = menuekartenData.find(m => m.id === id);

                document.getElementById('mk_id').value = mk.id;
                document.getElementById('mk_name').value = mk.name;
                document.getElementById('mk_typ').value = mk.typ;
                document.getElementById('mk_aktiv').checked = mk.aktiv;
                document.getElementById('mk_bemerkungen').value = mk.bemerkungen || '';

                currentMenuekarteGerichte = mk.gerichte ? [...mk.gerichte] : [];
                renderGerichteListe();
                updateKalkulationPreview();
            } else {
                title.textContent = 'Neue Men√ºkarte erstellen';
                document.getElementById('menuekarteForm').reset();
                currentMenuekarteGerichte = [];
                renderGerichteListe();
                updateKalkulationPreview();
            }

            toggleWochentagVisibility(); // Initial visibility check
            modal.classList.add('active');
        }

        function closeMenuekarteModal() {
            document.getElementById('menuekarteModal').classList.remove('active');
            currentEditId = null;
            currentMenuekarteGerichte = [];
        }

        function addRezeptToKarte() {
            const rezeptId = parseInt(document.getElementById('mk_rezept_select').value);
            const kategorie = document.getElementById('mk_rezept_kategorie').value;
            const wochentag = document.getElementById('mk_rezept_wochentag').value || null;

            if (!rezeptId) {
                alert('Bitte ein Rezept ausw√§hlen!');
                return;
            }

            // Check if already added
            if (currentMenuekarteGerichte.find(g => g.rezept_id === rezeptId)) {
                alert('Dieses Rezept wurde bereits hinzugef√ºgt!');
                return;
            }

            currentMenuekarteGerichte.push({
                rezept_id: rezeptId,
                kategorie: kategorie,
                wochentag: wochentag,
                reihenfolge: currentMenuekarteGerichte.length + 1
            });

            renderGerichteListe();
            updateKalkulationPreview();

            // Reset dropdowns
            document.getElementById('mk_rezept_select').value = '';
            document.getElementById('mk_rezept_wochentag').value = '';
        }

        function removeGerichtFromKarte(index) {
            currentMenuekarteGerichte.splice(index, 1);

            // Update reihenfolge
            currentMenuekarteGerichte.forEach((g, i) => g.reihenfolge = i + 1);

            renderGerichteListe();
            updateKalkulationPreview();
        }

        // Repariert Men√ºkarte-Gerichte indem rezept_name zu echten rezept_ids aufgel√∂st werden
        async function repairMenuekarteRezepte() {
            if (!currentMenuekarteGerichte || currentMenuekarteGerichte.length === 0) {
                alert('Keine Gerichte zum Reparieren vorhanden.');
                return;
            }

            // Stelle sicher dass Rezepte geladen sind
            if (!rezepteData || rezepteData.length === 0) {
                await loadRezepte();
            }

            console.log('üîß Starte Reparatur der Men√ºkarte...');
            console.log('üìä Vorhandene Rezepte:', rezepteData.length);

            let repaired = 0;
            let notFound = [];

            for (let i = 0; i < currentMenuekarteGerichte.length; i++) {
                const gericht = currentMenuekarteGerichte[i];

                // Versuche das Rezept zu finden
                let rezept = rezepteData.find(r => r.id === gericht.rezept_id);

                if (!rezept && gericht.rezept_name) {
                    // Suche nach exaktem Namen
                    rezept = rezepteData.find(r => r.name === gericht.rezept_name);

                    if (!rezept) {
                        // Suche nach √§hnlichem Namen (enth√§lt)
                        rezept = rezepteData.find(r =>
                            r.name.toLowerCase().includes(gericht.rezept_name.toLowerCase()) ||
                            gericht.rezept_name.toLowerCase().includes(r.name.toLowerCase())
                        );
                    }
                }

                if (rezept) {
                    console.log(`  ‚úì ${gericht.rezept_name || 'ID:' + gericht.rezept_id} ‚Üí ${rezept.name} (ID: ${rezept.id})`);
                    currentMenuekarteGerichte[i].rezept_id = rezept.id;
                    repaired++;
                } else {
                    console.warn(`  ‚úó Nicht gefunden: ${gericht.rezept_name || 'ID:' + gericht.rezept_id}`);
                    notFound.push(gericht.rezept_name || `ID: ${gericht.rezept_id}`);
                }
            }

            // Entferne nicht gefundene Gerichte
            if (notFound.length > 0) {
                currentMenuekarteGerichte = currentMenuekarteGerichte.filter(g => {
                    const rezept = rezepteData.find(r => r.id === g.rezept_id);
                    return rezept !== undefined;
                });
            }

            renderGerichteListe();
            updateKalkulationPreview();

            let message = `‚úÖ Reparatur abgeschlossen!\n\n‚Ä¢ Repariert: ${repaired} Gerichte`;
            if (notFound.length > 0) {
                message += `\n‚Ä¢ Nicht gefunden (entfernt): ${notFound.length}\n\n‚ö†Ô∏è Diese Rezepte fehlen:\n${notFound.slice(0, 10).join('\n')}`;
                if (notFound.length > 10) message += '\n...';
            }
            message += '\n\nüíæ Klicke auf "Men√ºkarte speichern" um die √Ñnderungen zu √ºbernehmen.';
            alert(message);
        }

        // Toggle Wochentag Visibility based on Menu Type
        function toggleWochentagVisibility() {
            const typ = document.getElementById('mk_typ').value;
            const container = document.getElementById('mk_wochentag_container');
            if (container) {
                if (typ === 'mittagsmenu') {
                    container.style.display = 'block';
                } else {
                    container.style.display = 'none';
                    document.getElementById('mk_rezept_wochentag').value = '';
                }
            }
        }

        function renderGerichteListe() {
            const container = document.getElementById('mk_gerichte_container');
            if (!container) return;

            if (currentMenuekarteGerichte.length === 0) {
                container.innerHTML = '<p style="color: #999; font-style: italic;">Noch keine Gerichte hinzugef√ºgt</p>';
                return;
            }

            // DEBUG: Pr√ºfe ob Rezepte gefunden werden
            let notFoundCount = 0;
            let notFoundNames = [];
            currentMenuekarteGerichte.forEach(g => {
                const rezept = rezepteData.find(r => r.id === g.rezept_id);
                if (!rezept) {
                    notFoundCount++;
                    // Versuche nach Name zu finden falls vorhanden
                    if (g.rezept_name) {
                        notFoundNames.push(g.rezept_name);
                    } else {
                        notFoundNames.push(`ID: ${g.rezept_id}`);
                    }
                }
            });

            if (notFoundCount > 0 && notFoundCount === currentMenuekarteGerichte.length) {
                // ALLE Rezepte fehlen - zeige Reparatur-Option
                container.innerHTML = `
                    <div style="background: #2a1f1f; border: 2px solid #c9302c; border-radius: 8px; padding: 1.5rem; margin: 1rem 0;">
                        <h4 style="color: #c9302c; margin-bottom: 1rem;">‚ö†Ô∏è ${notFoundCount} Rezepte nicht gefunden!</h4>
                        <p style="color: #ccc; margin-bottom: 1rem;">Die Men√ºkarte enth√§lt ${notFoundCount} Gerichte, aber die zugeh√∂rigen Rezepte wurden nicht in der Datenbank gefunden.</p>
                        <p style="color: #999; margin-bottom: 1rem;"><strong>M√∂gliche Ursachen:</strong></p>
                        <ul style="color: #999; margin-left: 1.5rem; margin-bottom: 1rem;">
                            <li>Die Rezepte wurden noch nicht importiert</li>
                            <li>Die Rezept-IDs stimmen nicht √ºberein</li>
                        </ul>
                        <p style="color: #999; margin-bottom: 1rem;"><strong>Fehlende Rezepte:</strong> ${notFoundNames.slice(0, 5).join(', ')}${notFoundNames.length > 5 ? '...' : ''}</p>
                        <button type="button" class="btn btn-warning" onclick="repairMenuekarteRezepte()" style="margin-top: 0.5rem;">
                            üîß Rezepte automatisch reparieren
                        </button>
                    </div>
                `;
                return;
            }

            // Check: Verwenden Gerichte Wochentage?
            // FIX: Bei Mittagskarten IMMER die Wochentags-Ansicht erzwingen
            const mkTyp = document.getElementById('mk_typ') ? document.getElementById('mk_typ').value : '';
            const hasWochentage = currentMenuekarteGerichte.some(g => g.wochentag) || mkTyp === 'mittagsmenu';

            if (hasWochentage) {
                // === WOCHENTAG-ANSICHT MIT DRAG & DROP ===
                const wochentagOrder = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag'];
                const kategorieOrder = ['Vorspeise', 'Suppe', 'Hauptgang', 'Dessert', 'Beilage'];
                let html = '<p style="color: #888; font-size: 0.85rem; margin-bottom: 1rem;">üí° Ziehe Gerichte per Drag & Drop um sie zwischen Wochentagen zu verschieben</p>';

                wochentagOrder.forEach(wochentag => {
                    const gerichteAmTag = currentMenuekarteGerichte.filter(g => g.wochentag === wochentag);

                    // Zeige Wochentag auch wenn leer (als Drop-Zone)
                    html += `<div class="wochentag-section" data-wochentag="${wochentag}"
                        ondragover="handleWochentagDragOver(event, '${wochentag}')"
                        ondragleave="handleWochentagDragLeave(event)"
                        ondrop="handleWochentagDrop(event, '${wochentag}')">`;

                    html += `<h3 style="margin-top: 1rem; color: var(--dakota-gold); border-bottom: 3px solid var(--dakota-gold); padding-bottom: 0.5rem; font-size: 1.4rem;">
                        üìÖ ${wochentag} <span style="font-size: 0.9rem; color: #999;">(${gerichteAmTag.length} Gerichte)</span>
                    </h3>`;

                    if (gerichteAmTag.length === 0) {
                        html += `<div class="drop-zone" data-wochentag="${wochentag}">Gericht hierher ziehen</div>`;
                    } else {
                        // Nach Kategorie gruppieren
                        const byKategorie = {};
                        gerichteAmTag.forEach(g => {
                            if (!byKategorie[g.kategorie]) byKategorie[g.kategorie] = [];
                            byKategorie[g.kategorie].push(g);
                        });

                        kategorieOrder.forEach(kategorie => {
                            if (!byKategorie[kategorie]) return;

                            html += `<h4 style="margin-top: 1.2rem; margin-left: 1rem; color: #666; font-size: 1.1rem;">${kategorie}</h4>`;
                            html += `<table class="data-table" style="margin-left: 1rem;" data-wochentag="${wochentag}" data-kategorie="${kategorie}">
                                <thead><tr><th style="width: 40px;"></th><th>Rezept</th><th>Preis</th><th>Food Cost</th><th>Aktionen</th></tr></thead>
                                <tbody class="drag-container">`;

                            byKategorie[kategorie].forEach(gericht => {
                                const rezept = rezepteData.find(r => r.id === gericht.rezept_id);
                                if (!rezept) return;

                                const wareneinsatz = calculateRezeptWareneinsatz(rezept);
                                const foodCost = (wareneinsatz / rezept.verkaufspreis * 100).toFixed(1);
                                const foodCostClass = foodCost < 30 ? 'success' : foodCost < 35 ? 'warning' : 'danger';
                                const globalIndex = currentMenuekarteGerichte.indexOf(gericht);

                                html += `
                                    <tr class="draggable-row" draggable="true" data-index="${globalIndex}" data-wochentag="${wochentag}" data-kategorie="${kategorie}">
                                        <td class="drag-handle" title="Ziehen zum Verschieben">‚ãÆ‚ãÆ</td>
                                        <td><strong>${rezept.name}</strong>${rezept.beschreibung ? '<br><small>' + rezept.beschreibung.substring(0, 60) + '...</small>' : ''}</td>
                                        <td>CHF ${rezept.verkaufspreis.toFixed(2)}</td>
                                        <td><span class="badge badge-${foodCostClass}">${foodCost}%</span></td>
                                        <td style="white-space: nowrap;">
                                            <button type="button" class="btn-icon" onclick="viewGerichtKalkulation(${rezept.id})" title="Kalkulation">üßÆ</button>
                                            <button type="button" class="btn-icon" onclick="viewGerichtRezept(${rezept.id})" title="Rezeptanleitung">üìù</button>
                                            <button type="button" class="btn-icon" onclick="viewGerichtAllergene(${rezept.id})" title="Allergene">‚ö†Ô∏è</button>
                                            <button type="button" class="btn-icon delete" onclick="removeGerichtFromKarte(${globalIndex})" title="Entfernen">üóëÔ∏è</button>
                                        </td>
                                    </tr>
                                `;
                            });

                            html += '</tbody></table>';
                        });
                    }

                    html += '</div>'; // wochentag-section
                });

                // Gerichte OHNE Wochentag (falls vorhanden)
                const gerichteOhneTag = currentMenuekarteGerichte.filter(g => !g.wochentag);
                if (gerichteOhneTag.length > 0) {
                    html += `<div class="wochentag-section" data-wochentag="">`;
                    html += `<h3 style="margin-top: 2rem; color: #999; border-bottom: 2px solid #ddd; padding-bottom: 0.5rem;">Ohne Wochentag</h3>`;

                    const byKategorie = {};
                    gerichteOhneTag.forEach(g => {
                        if (!byKategorie[g.kategorie]) byKategorie[g.kategorie] = [];
                        byKategorie[g.kategorie].push(g);
                    });

                    kategorieOrder.forEach(kategorie => {
                        if (!byKategorie[kategorie]) return;

                        html += `<h4 style="margin-top: 1rem; margin-left: 1rem; color: #666;">${kategorie}</h4>`;
                        html += `<table class="data-table" style="margin-left: 1rem;" data-wochentag="" data-kategorie="${kategorie}">
                            <thead><tr><th style="width: 40px;"></th><th>Rezept</th><th>Preis</th><th>Food Cost</th><th>Aktionen</th></tr></thead>
                            <tbody class="drag-container">`;

                        byKategorie[kategorie].forEach(gericht => {
                            const rezept = rezepteData.find(r => r.id === gericht.rezept_id);
                            if (!rezept) return;

                            const wareneinsatz = calculateRezeptWareneinsatz(rezept);
                            const foodCost = (wareneinsatz / rezept.verkaufspreis * 100).toFixed(1);
                            const foodCostClass = foodCost < 30 ? 'success' : foodCost < 35 ? 'warning' : 'danger';
                            const globalIndex = currentMenuekarteGerichte.indexOf(gericht);

                            html += `
                                <tr class="draggable-row" draggable="true" data-index="${globalIndex}" data-wochentag="" data-kategorie="${kategorie}">
                                    <td class="drag-handle" title="Ziehen zum Verschieben">‚ãÆ‚ãÆ</td>
                                    <td><strong>${rezept.name}</strong>${rezept.beschreibung ? '<br><small>' + rezept.beschreibung.substring(0, 60) + '...</small>' : ''}</td>
                                    <td>CHF ${rezept.verkaufspreis.toFixed(2)}</td>
                                    <td><span class="badge badge-${foodCostClass}">${foodCost}%</span></td>
                                    <td style="white-space: nowrap;">
                                        <button type="button" class="btn-icon" onclick="viewGerichtKalkulation(${rezept.id})" title="Kalkulation">üßÆ</button>
                                        <button type="button" class="btn-icon" onclick="viewGerichtRezept(${rezept.id})" title="Rezeptanleitung">üìù</button>
                                        <button type="button" class="btn-icon" onclick="viewGerichtAllergene(${rezept.id})" title="Allergene">‚ö†Ô∏è</button>
                                        <button type="button" class="btn-icon delete" onclick="removeGerichtFromKarte(${globalIndex})" title="Entfernen">üóëÔ∏è</button>
                                    </td>
                                </tr>
                            `;
                        });

                        html += '</tbody></table>';
                    });

                    html += '</div>'; // wochentag-section
                }

                container.innerHTML = html;

                // Initialize Drag & Drop f√ºr Wochentag-Ansicht
                initDragAndDropWithWochentag();

            } else {
                // === ALTE LOGIK: Nur nach Kategorie gruppieren (f√ºr Abendkarten ohne Wochentage) ===
                // MIT DRAG & DROP f√ºr Reihenfolge!
                const byKategorie = {};
                currentMenuekarteGerichte.forEach(gericht => {
                    if (!byKategorie[gericht.kategorie]) byKategorie[gericht.kategorie] = [];
                    byKategorie[gericht.kategorie].push(gericht);
                });

                let html = '<p style="color: #888; font-size: 0.85rem; margin-bottom: 1rem;">üí° Ziehe Gerichte per Drag & Drop um die Reihenfolge zu √§ndern</p>';
                const kategorieOrder = ['Vorspeise', 'Suppe', 'Hauptgang', 'Dessert', 'Beilage'];

                kategorieOrder.forEach(kategorie => {
                    if (!byKategorie[kategorie]) return;

                    html += `<h4 style="margin-top: 1rem; color: var(--dakota-gold);">${kategorie}</h4>`;
                    html += `<table class="data-table" data-kategorie="${kategorie}"><thead><tr><th style="width: 40px;"></th><th>Rezept</th><th>Preis</th><th>Food Cost</th><th>Aktionen</th></tr></thead><tbody class="drag-container">`;

                    byKategorie[kategorie].forEach((gericht, index) => {
                        const rezept = rezepteData.find(r => r.id === gericht.rezept_id);
                        if (!rezept) return;

                        const wareneinsatz = calculateRezeptWareneinsatz(rezept);
                        const foodCost = (wareneinsatz / rezept.verkaufspreis * 100).toFixed(1);
                        const foodCostClass = foodCost < 30 ? 'success' : foodCost < 35 ? 'warning' : 'danger';

                        const globalIndex = currentMenuekarteGerichte.indexOf(gericht);

                        html += `
                            <tr class="draggable-row" draggable="true" data-index="${globalIndex}" data-kategorie="${kategorie}">
                                <td class="drag-handle" title="Ziehen zum Sortieren">‚ãÆ‚ãÆ</td>
                                <td><strong>${rezept.name}</strong>${rezept.beschreibung ? '<br><small>' + rezept.beschreibung.substring(0, 60) + '...</small>' : ''}</td>
                                <td>CHF ${rezept.verkaufspreis.toFixed(2)}</td>
                                <td><span class="badge badge-${foodCostClass}">${foodCost}%</span></td>
                                <td style="white-space: nowrap;">
                                    <button type="button" class="btn-icon" onclick="viewGerichtKalkulation(${rezept.id})" title="Kalkulation">üßÆ</button>
                                    <button type="button" class="btn-icon" onclick="viewGerichtRezept(${rezept.id})" title="Rezeptanleitung">üìù</button>
                                    <button type="button" class="btn-icon" onclick="viewGerichtAllergene(${rezept.id})" title="Allergene">‚ö†Ô∏è</button>
                                    <button type="button" class="btn-icon delete" onclick="removeGerichtFromKarte(${globalIndex})" title="Entfernen">üóëÔ∏è</button>
                                </td>
                            </tr>
                        `;
                    });

                    html += '</tbody></table>';
                });

                container.innerHTML = html;

                // Initialize Drag & Drop events
                initDragAndDrop();
            }
        }

        // ===== DRAG & DROP FUNCTIONS =====
        function initDragAndDrop() {
            const rows = document.querySelectorAll('.draggable-row');

            rows.forEach(row => {
                row.addEventListener('dragstart', handleDragStart);
                row.addEventListener('dragend', handleDragEnd);
                row.addEventListener('dragover', handleDragOver);
                row.addEventListener('dragenter', handleDragEnter);
                row.addEventListener('dragleave', handleDragLeave);
                row.addEventListener('drop', handleDrop);
            });
        }

        let draggedRow = null;

        function handleDragStart(e) {
            draggedRow = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.index);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.draggable-row').forEach(row => {
                row.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            // Nur innerhalb derselben Kategorie erlauben
            if (this.dataset.kategorie === draggedRow.dataset.kategorie && this !== draggedRow) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (this === draggedRow) return;

            // Nur innerhalb derselben Kategorie erlauben
            if (this.dataset.kategorie !== draggedRow.dataset.kategorie) {
                alert('Gerichte k√∂nnen nur innerhalb derselben Kategorie verschoben werden.');
                return;
            }

            const fromIndex = parseInt(draggedRow.dataset.index);
            const toIndex = parseInt(this.dataset.index);

            // Reorder the array
            reorderGerichte(fromIndex, toIndex);

            this.classList.remove('drag-over');
        }

        function reorderGerichte(fromIndex, toIndex) {
            // Remove item from original position
            const [movedItem] = currentMenuekarteGerichte.splice(fromIndex, 1);

            // Insert at new position
            if (toIndex > fromIndex) {
                currentMenuekarteGerichte.splice(toIndex, 0, movedItem);
            } else {
                currentMenuekarteGerichte.splice(toIndex, 0, movedItem);
            }

            // Update reihenfolge
            currentMenuekarteGerichte.forEach((g, i) => g.reihenfolge = i + 1);

            // Re-render
            renderGerichteListe();
            updateKalkulationPreview();
        }

        // ===== DRAG & DROP MIT WOCHENTAG-SUPPORT =====
        let draggedRowWithWochentag = null;

        function initDragAndDropWithWochentag() {
            const rows = document.querySelectorAll('.draggable-row');

            rows.forEach(row => {
                row.addEventListener('dragstart', handleDragStartWithWochentag);
                row.addEventListener('dragend', handleDragEndWithWochentag);
                row.addEventListener('dragover', handleDragOverWithWochentag);
                row.addEventListener('dragenter', handleDragEnterWithWochentag);
                row.addEventListener('dragleave', handleDragLeaveWithWochentag);
                row.addEventListener('drop', handleDropWithWochentag);
            });
        }

        function handleDragStartWithWochentag(e) {
            draggedRowWithWochentag = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.index);
        }

        function handleDragEndWithWochentag(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.draggable-row').forEach(row => {
                row.classList.remove('drag-over');
            });
            document.querySelectorAll('.wochentag-section').forEach(section => {
                section.classList.remove('drag-over');
            });
            document.querySelectorAll('.drop-zone').forEach(zone => {
                zone.classList.remove('drag-over');
            });
        }

        function handleDragOverWithWochentag(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnterWithWochentag(e) {
            e.preventDefault();
            if (this !== draggedRowWithWochentag) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeaveWithWochentag(e) {
            this.classList.remove('drag-over');
        }

        function handleDropWithWochentag(e) {
            e.preventDefault();
            e.stopPropagation();

            if (this === draggedRowWithWochentag) return;

            const fromIndex = parseInt(draggedRowWithWochentag.dataset.index);
            const toIndex = parseInt(this.dataset.index);
            const targetWochentag = this.dataset.wochentag;
            const targetKategorie = this.dataset.kategorie;

            // Gericht holen und Wochentag/Kategorie aktualisieren
            const gericht = currentMenuekarteGerichte[fromIndex];
            if (gericht) {
                gericht.wochentag = targetWochentag || '';
                gericht.kategorie = targetKategorie;
            }

            // Reorder
            reorderGerichte(fromIndex, toIndex);

            this.classList.remove('drag-over');
        }

        // Wochentag Drop-Zone Handler (f√ºr leere Wochentage)
        function handleWochentagDragOver(e, wochentag) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const section = e.target.closest('.wochentag-section');
            if (section) {
                section.classList.add('drag-over');
            }

            const dropZone = e.target.closest('.drop-zone');
            if (dropZone) {
                dropZone.classList.add('drag-over');
            }
        }

        function handleWochentagDragLeave(e) {
            const section = e.target.closest('.wochentag-section');
            if (section && !section.contains(e.relatedTarget)) {
                section.classList.remove('drag-over');
            }

            const dropZone = e.target.closest('.drop-zone');
            if (dropZone) {
                dropZone.classList.remove('drag-over');
            }
        }

        function handleWochentagDrop(e, wochentag) {
            e.preventDefault();

            if (!draggedRowWithWochentag) return;

            const fromIndex = parseInt(draggedRowWithWochentag.dataset.index);

            // Gericht holen und Wochentag aktualisieren
            const gericht = currentMenuekarteGerichte[fromIndex];
            if (gericht) {
                gericht.wochentag = wochentag;
                console.log(`‚úÖ Gericht nach ${wochentag} verschoben`);
            }

            // Re-render
            renderGerichteListe();
            updateKalkulationPreview();

            // Cleanup
            document.querySelectorAll('.wochentag-section').forEach(section => {
                section.classList.remove('drag-over');
            });
            document.querySelectorAll('.drop-zone').forEach(zone => {
                zone.classList.remove('drag-over');
            });
        }

        function updateKalkulationPreview() {
            if (currentMenuekarteGerichte.length === 0) {
                document.getElementById('mk_anzahl_gerichte').textContent = '0';
                document.getElementById('mk_avg_foodcost').textContent = '0%';
                document.getElementById('mk_avg_preis').textContent = '0.-';
                document.getElementById('mk_total_wareneinsatz').textContent = '0.-';
                return;
            }

            let totalWareneinsatz = 0;
            let totalVerkaufspreis = 0;
            let totalFoodCost = 0;

            currentMenuekarteGerichte.forEach(gericht => {
                const rezept = rezepteData.find(r => r.id === gericht.rezept_id);
                if (rezept) {
                    const wareneinsatz = calculateRezeptWareneinsatz(rezept);
                    totalWareneinsatz += wareneinsatz;
                    totalVerkaufspreis += rezept.verkaufspreis;
                    totalFoodCost += (wareneinsatz / rezept.verkaufspreis * 100);
                }
            });

            const avgFoodCost = (totalFoodCost / currentMenuekarteGerichte.length).toFixed(1);
            const avgPreis = (totalVerkaufspreis / currentMenuekarteGerichte.length).toFixed(2);

            document.getElementById('mk_anzahl_gerichte').textContent = currentMenuekarteGerichte.length;
            document.getElementById('mk_avg_foodcost').textContent = avgFoodCost + '%';
            document.getElementById('mk_avg_preis').textContent = 'CHF ' + avgPreis;
            document.getElementById('mk_total_wareneinsatz').textContent = 'CHF ' + totalWareneinsatz.toFixed(2);

            // Color coding
            const foodCostEl = document.getElementById('mk_avg_foodcost');
            foodCostEl.style.color = avgFoodCost < 30 ? 'var(--success)' : avgFoodCost < 35 ? 'var(--warning)' : 'var(--danger)';
        }

        async function saveMenuekarte(event) {
            event.preventDefault();

            if (currentMenuekarteGerichte.length === 0) {
                alert('Bitte mindestens ein Gericht hinzuf√ºgen!');
                return;
            }

            const data = {
                name: document.getElementById('mk_name').value,
                typ: document.getElementById('mk_typ').value,
                aktiv: document.getElementById('mk_aktiv').checked,
                bemerkungen: document.getElementById('mk_bemerkungen').value,
                datum_erstellt: new Date().toISOString(),
                gerichte: currentMenuekarteGerichte
            };

            try {
                if (currentEditId) {
                    await updateMenuekarte(currentEditId, data);
                    alert('‚úÖ Men√ºkarte aktualisiert!');
                } else {
                    await addMenuekarte(data);
                    alert('‚úÖ Men√ºkarte erstellt!');
                }

                closeMenuekarteModal();
                await loadMenuekartenTab();
            } catch (error) {
                alert('‚ùå Fehler beim Speichern: ' + error);
                console.error(error);
            }
        }

        function filterMenuekarten() {
            const filterTyp = document.getElementById('filterMenuekartenTyp').value;

            if (!filterTyp) {
                renderMenuekartenTable(menuekartenData);
                return;
            }

            const filtered = menuekartenData.filter(mk => mk.typ === filterTyp);
            renderMenuekartenTable(filtered);
        }

        async function deleteMenuekarteConfirm(id) {
            const mk = menuekartenData.find(m => m.id === id);
            if (!confirm(`Men√ºkarte "${mk.name}" wirklich l√∂schen?`)) return;

            try {
                await deleteMenuekarte(id);
                alert('‚úÖ Men√ºkarte gel√∂scht!');
                await loadMenuekartenTab();
            } catch (error) {
                alert('‚ùå Fehler beim L√∂schen: ' + error);
            }
        }

        function viewMenuekarte(id) {
            const mk = menuekartenData.find(m => m.id === id);

            let html = `
                <div style="max-width: 800px; margin: 2rem auto; padding: 2rem; background: white; border-radius: 12px;">
                    <h2 style="text-align: center; color: var(--dakota-gold); margin-bottom: 1rem;">${mk.name}</h2>
                    <p style="text-align: center; color: #666; margin-bottom: 2rem;">${mk.typ === 'abendkarte' ? 'üåô Abendkarte' : '‚òÄÔ∏è Mittagsmen√º'}</p>
            `;

            // Gruppiert nach Kategorie
            const byKategorie = {};
            mk.gerichte.forEach(gericht => {
                if (!byKategorie[gericht.kategorie]) byKategorie[gericht.kategorie] = [];
                byKategorie[gericht.kategorie].push(gericht);
            });

            const kategorieOrder = ['Vorspeise', 'Suppe', 'Hauptgang', 'Dessert', 'Beilage'];

            kategorieOrder.forEach(kategorie => {
                if (!byKategorie[kategorie]) return;

                html += `<h3 style="margin-top: 2rem; color: var(--dakota-dark);">${kategorie}</h3>`;

                byKategorie[kategorie].forEach(gericht => {
                    const rezept = rezepteData.find(r => r.id === gericht.rezept_id);
                    if (!rezept) return;

                    html += `
                        <div style="margin: 1rem 0; padding: 1rem; border-left: 3px solid var(--dakota-gold);">
                            <div style="display: flex; justify-content: space-between; align-items: baseline;">
                                <strong style="font-size: 1.1rem;">${rezept.name}</strong>
                                <span style="color: var(--dakota-gold); font-weight: 700;">CHF ${rezept.verkaufspreis.toFixed(2)}</span>
                            </div>
                            ${rezept.beschreibung ? `<p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">${rezept.beschreibung}</p>` : ''}
                        </div>
                    `;
                });
            });

            html += '</div>';

            // Create modal for view
            const viewModal = document.createElement('div');
            viewModal.className = 'modal active';
            viewModal.innerHTML = `<div class="modal-content" style="max-width: 900px;">${html}<button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Schlie√üen</button></div>`;
            document.body.appendChild(viewModal);
        }

        // ===== MEN√úKARTEN-GERICHT DETAIL-VIEWS =====

        // Zeigt Kalkulations-Details f√ºr ein Gericht
        function viewGerichtKalkulation(rezept_id) {
            const rezept = rezepteData.find(r => r.id === rezept_id);
            if (!rezept) {
                alert('Rezept nicht gefunden!');
                return;
            }

            const wareneinsatz = calculateRezeptWareneinsatz(rezept);
            const foodCost = (wareneinsatz / rezept.verkaufspreis * 100).toFixed(1);
            const foodCostClass = foodCost < 30 ? 'success' : foodCost < 35 ? 'warning' : 'danger';
            const marge = (rezept.verkaufspreis - wareneinsatz).toFixed(2);

            // Zutaten mit Preisen
            let zutatenHtml = '<ul style="margin: 1rem 0; list-style: none; padding: 0;">';
            if (rezept.zutaten && rezept.zutaten.length > 0) {
                rezept.zutaten.forEach(zutat => {
                    const lm = lebensmittelData.find(l => l.gastro_id === zutat.produkt_id);
                    if (lm) {
                        // FIX: Korrekte Preisberechnung mit Einheiten-Umrechnung
                        // lm.preis ist pro kg/L, zutat.menge in g/ml (au√üer bei St√ºck)
                        const faktor = lm.einheit === 'Stk' ? 1 : 1000;
                        const einzelpreis = ((zutat.menge / faktor) * lm.preis).toFixed(2);
                        zutatenHtml += `
                            <li style="display: flex; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid #eee;">
                                <span>${lm.name} <span style="color: #666;">(${zutat.menge} ${zutat.einheit})</span></span>
                                <strong>CHF ${einzelpreis}</strong>
                            </li>
                        `;
                    } else {
                        zutatenHtml += `
                            <li style="display: flex; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid #eee; color: #999;">
                                <span>‚ö†Ô∏è Produkt ID ${zutat.produkt_id} <span style="color: #666;">(${zutat.menge} ${zutat.einheit})</span></span>
                                <strong>-</strong>
                            </li>
                        `;
                    }
                });
            } else {
                zutatenHtml += '<li style="color: #999; font-style: italic; padding: 0.5rem;">Keine Zutaten hinterlegt</li>';
            }
            zutatenHtml += '</ul>';

            const html = `
                <h2 style="margin-bottom: 1.5rem; color: var(--dakota-dark);">üßÆ Kalkulation: ${rezept.name}</h2>

                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 2rem;">
                    <div style="text-align: center; padding: 1.5rem; background: #f8f9fa; border-radius: 8px;">
                        <div style="font-size: 1.8rem; font-weight: bold; color: var(--dakota-dark);">CHF ${wareneinsatz.toFixed(2)}</div>
                        <div style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">Wareneinsatz</div>
                    </div>
                    <div style="text-align: center; padding: 1.5rem; background: #f8f9fa; border-radius: 8px;">
                        <div style="font-size: 1.8rem; font-weight: bold;">
                            <span class="badge badge-${foodCostClass}" style="font-size: 1.5rem; padding: 0.5rem 1rem;">${foodCost}%</span>
                        </div>
                        <div style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">Food Cost</div>
                    </div>
                    <div style="text-align: center; padding: 1.5rem; background: #f8f9fa; border-radius: 8px;">
                        <div style="font-size: 1.8rem; font-weight: bold; color: var(--success-color);">CHF ${marge}</div>
                        <div style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">Marge</div>
                    </div>
                    <div style="text-align: center; padding: 1.5rem; background: #f8f9fa; border-radius: 8px;">
                        <div style="font-size: 1.8rem; font-weight: bold; color: var(--dakota-gold);">CHF ${rezept.verkaufspreis.toFixed(2)}</div>
                        <div style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">Verkaufspreis</div>
                    </div>
                </div>

                <h3 style="margin-bottom: 1rem; color: var(--dakota-dark);">Zutaten mit Einzelpreisen</h3>
                ${zutatenHtml}

                <div style="margin-top: 2rem; padding-top: 1rem; border-top: 2px solid var(--dakota-gold); display: flex; justify-content: space-between; align-items: center;">
                    <button class="btn btn-primary" onclick="this.closest('.modal').remove(); editRezept(${rezept.id})">‚úèÔ∏è Rezept bearbeiten</button>
                    <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Schlie√üen</button>
                </div>
            `;

            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `<div class="modal-content" style="max-width: 800px;">${html}</div>`;
            document.body.appendChild(modal);
        }

        // Zeigt Rezeptanleitung f√ºr ein Gericht
        function viewGerichtRezept(rezept_id) {
            const rezept = rezepteData.find(r => r.id === rezept_id);
            if (!rezept) {
                alert('Rezept nicht gefunden!');
                return;
            }

            let zubereitungHtml = '';
            if (rezept.zubereitung && rezept.zubereitung.length > 0) {
                zubereitungHtml = '<ol style="margin: 1rem 0; padding-left: 1.5rem; line-height: 1.8;">';
                rezept.zubereitung.forEach(schritt => {
                    zubereitungHtml += `<li style="margin-bottom: 1rem; padding-left: 0.5rem;">${schritt}</li>`;
                });
                zubereitungHtml += '</ol>';
            } else {
                zubereitungHtml = '<p style="color: #999; font-style: italic; margin: 1rem 0;">Keine Zubereitungsschritte hinterlegt.</p>';
            }

            const html = `
                <h2 style="margin-bottom: 1.5rem; color: var(--dakota-dark);">üìù Rezept: ${rezept.name}</h2>

                <div style="display: flex; gap: 2rem; margin-bottom: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                    <div style="color: #666;"><strong>‚è±Ô∏è Zubereitungszeit:</strong> ${rezept.zubereitungszeit || 'Nicht angegeben'}</div>
                    <div style="color: #666;"><strong>üìä Schwierigkeit:</strong> ${rezept.schwierigkeit || 'Nicht angegeben'}</div>
                    <div style="color: #666;"><strong>üë• Portionen:</strong> ${rezept.portionen || '1'}</div>
                </div>

                <h3 style="margin-bottom: 1rem; color: var(--dakota-dark);">Zubereitung</h3>
                ${zubereitungHtml}

                ${rezept.bemerkung ? `
                    <div style="margin-top: 2rem; padding: 1rem; background: #fff9e6; border-left: 4px solid var(--dakota-gold); border-radius: 4px;">
                        <strong>üí° Tipp:</strong> ${rezept.bemerkung}
                    </div>
                ` : ''}

                ${rezept.quelle ? `
                    <div style="margin-top: 1rem; color: #666; font-size: 0.9rem;">
                        <strong>üìö Quelle:</strong> ${rezept.quelle.startsWith('http') ? `<a href="${rezept.quelle}" target="_blank" rel="noopener">${rezept.quelle}</a>` : rezept.quelle}
                    </div>
                ` : ''}

                <div style="margin-top: 2rem; padding-top: 1rem; border-top: 2px solid var(--dakota-gold); display: flex; justify-content: space-between; align-items: center;">
                    <button class="btn btn-primary" onclick="this.closest('.modal').remove(); editRezept(${rezept.id})">‚úèÔ∏è Zubereitungsschritte bearbeiten</button>
                    <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Schlie√üen</button>
                </div>
            `;

            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `<div class="modal-content" style="max-width: 800px;">${html}</div>`;
            document.body.appendChild(modal);
        }

        // Zeigt Allergene f√ºr ein Gericht
        function viewGerichtAllergene(rezept_id) {
            const rezept = rezepteData.find(r => r.id === rezept_id);
            if (!rezept) {
                alert('Rezept nicht gefunden!');
                return;
            }

            let allergeneHtml = '';
            if (rezept.allergene && rezept.allergene.length > 0) {
                allergeneHtml = '<div style="display: flex; flex-wrap: wrap; gap: 0.75rem; margin: 1.5rem 0;">';
                rezept.allergene.forEach(allergen => {
                    const icon = getAllergenIcon(allergen);
                    allergeneHtml += `
                        <span style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.75rem 1.25rem; background: #fff3cd; border: 2px solid #ffc107; border-radius: 25px; font-weight: 600; font-size: 1.05rem;">
                            <span style="font-size: 1.3rem;">${icon}</span> ${allergen}
                        </span>
                    `;
                });
                allergeneHtml += '</div>';
            } else {
                allergeneHtml = '<p style="color: #999; font-style: italic; margin: 1.5rem 0; font-size: 1.1rem;">‚úÖ Keine Allergene hinterlegt.</p>';
            }

            const html = `
                <h2 style="margin-bottom: 1.5rem; color: var(--dakota-dark);">‚ö†Ô∏è Allergene: ${rezept.name}</h2>

                <div style="padding: 1.25rem; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; margin-bottom: 1.5rem;">
                    <strong style="color: #856404;">‚ö†Ô∏è Hinweis:</strong>
                    <span style="color: #856404;">Bitte beachten Sie die folgenden Allergene in diesem Gericht.</span>
                </div>

                ${allergeneHtml}

                <div style="margin-top: 2rem; padding-top: 1rem; border-top: 2px solid var(--dakota-gold); display: flex; justify-content: space-between; align-items: center;">
                    <button class="btn btn-primary" onclick="this.closest('.modal').remove(); editRezept(${rezept.id})">‚úèÔ∏è Allergene bearbeiten</button>
                    <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Schlie√üen</button>
                </div>
            `;

            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `<div class="modal-content" style="max-width: 700px;">${html}</div>`;
            document.body.appendChild(modal);
        }

        // Helper: Allergen-Icons
        function getAllergenIcon(allergen) {
            const icons = {
                'Gluten': 'üåæ',
                'Milch': 'ü•õ',
                'Eier': 'ü•ö',
                'Fisch': 'üêü',
                'N√ºsse': 'ü•ú',
                'Erdn√ºsse': 'ü•ú',
                'Soja': 'ü´ò',
                'Sellerie': 'üåø',
                'Senf': 'üå≠',
                'Sesam': 'üå∞',
                'Sulfite': 'üç∑',
                'Lupinen': 'üå±',
                'Weichtiere': 'ü¶ë',
                'Krebstiere': 'ü¶û',
                'Laktose': 'ü•õ',
                'Schalenfr√ºchte': 'üå∞'
            };
            return icons[allergen] || '‚ö†Ô∏è';
        }

        // ===== DIENSTPLAN FUNKTIONEN =====
        let dienstplanMitarbeiter = [];
        let dienstplanSchichten = {};
        let dienstplanDiensttypen = [];
        let currentDienstplanMonth = new Date().getMonth();
        let currentDienstplanYear = new Date().getFullYear();

        const MONATE = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                        'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
        const WOCHENTAGE = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];

        const DEFAULT_DIENSTTYPEN = [
            { code: 'F', name: 'Fr√ºhst√ºck', zeit: '6:00-14:30', zeit2: '', farbe: '#3498db', reihenfolge: 1 },
            { code: 'S', name: 'Sp√§t', zeit: '12:00-22:00', zeit2: '', farbe: '#e67e22', reihenfolge: 2 },
            { code: 'TD', name: 'Teildienst', zeit: '9:00-14:00', zeit2: '18:00-22:00', farbe: '#8e44ad', reihenfolge: 3 },
            { code: 'X', name: 'Ruhetag', zeit: '', zeit2: '', farbe: '#95a5a6', reihenfolge: 4 },
            { code: 'W', name: 'Wunschfrei', zeit: '', zeit2: '', farbe: '#bdc3c7', reihenfolge: 5 },
            { code: 'K', name: 'Krank', zeit: '', zeit2: '', farbe: '#e74c3c', reihenfolge: 6 },
            { code: 'SP', name: 'Special', zeit: '', zeit2: '', farbe: '#f1c40f', reihenfolge: 7 },
            { code: 'HP', name: 'Halbpension', zeit: '', zeit2: '', farbe: '#27ae60', reihenfolge: 8 },
            { code: 'FE', name: 'Ferien', zeit: '', zeit2: '', farbe: '#9b59b6', reihenfolge: 9 }
        ];

        // Dienstplan initialisieren
        async function initDienstplan() {
            // Monat/Jahr Dropdowns f√ºllen
            const monatSelect = document.getElementById('dienstplanMonat');
            const jahrSelect = document.getElementById('dienstplanJahr');

            if (!monatSelect || !jahrSelect) return;

            // Monate
            monatSelect.innerHTML = MONATE.map((m, i) =>
                `<option value="${i}" ${i === currentDienstplanMonth ? 'selected' : ''}>${m}</option>`
            ).join('');

            // Jahre (2024-2027)
            jahrSelect.innerHTML = '';
            for (let y = 2024; y <= 2027; y++) {
                jahrSelect.innerHTML += `<option value="${y}" ${y === currentDienstplanYear ? 'selected' : ''}>${y}</option>`;
            }

            // Farbpicker Event
            const farbInput = document.getElementById('dt_farbe');
            if (farbInput) {
                farbInput.addEventListener('input', (e) => {
                    document.getElementById('dt_farbe_hex').textContent = e.target.value;
                });
            }

            await loadDiensttypen();
            await loadDienstplanMitarbeiter();
            await loadDienstplan();
        }

        // ===== DIENSTTYPEN FUNKTIONEN =====
        async function loadDiensttypen() {
            try {
                const { collection, getDocs, query, orderBy } = window.firebaseModules;
                const ref = collection(window.firestoreDB, 'dienstplan_diensttypen');
                const q = query(ref, orderBy('reihenfolge', 'asc'));
                const snapshot = await getDocs(q);

                dienstplanDiensttypen = [];
                snapshot.forEach(doc => {
                    dienstplanDiensttypen.push({ id: doc.id, ...doc.data() });
                });

                // Falls keine Diensttypen existieren, Standard anlegen
                if (dienstplanDiensttypen.length === 0) {
                    await createDefaultDiensttypen();
                }

                renderDiensttypenPalette();
                renderDienstplanLegende();
                console.log('‚úÖ Diensttypen geladen:', dienstplanDiensttypen.length);
            } catch (error) {
                console.error('Fehler beim Laden der Diensttypen:', error);
            }
        }

        async function createDefaultDiensttypen() {
            const { collection, doc, setDoc } = window.firebaseModules;

            for (const dt of DEFAULT_DIENSTTYPEN) {
                const newDocRef = doc(collection(window.firestoreDB, 'dienstplan_diensttypen'));
                await setDoc(newDocRef, dt);
                dienstplanDiensttypen.push({ id: newDocRef.id, ...dt });
            }
            console.log('‚úÖ Standard-Diensttypen angelegt');
        }

        function renderDiensttypenPalette() {
            const container = document.getElementById('diensttypenPalette');
            if (!container) return;

            container.innerHTML = dienstplanDiensttypen.map(dt => `
                <div class="palette-item"
                     draggable="true"
                     data-diensttyp="${dt.code}"
                     data-farbe="${dt.farbe}">
                    <span class="schicht-badge" style="background: ${dt.farbe}; color: ${getContrastColor(dt.farbe)}">${dt.code}</span>
                    <span class="palette-item-name">${dt.name}</span>
                </div>
            `).join('');

            // Drag Events f√ºr Palette
            container.querySelectorAll('.palette-item').forEach(item => {
                item.addEventListener('dragstart', handlePaletteDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        function renderDienstplanLegende() {
            const container = document.getElementById('dienstplanLegende');
            if (!container) return;

            container.innerHTML = dienstplanDiensttypen.map(dt => {
                const zeitDisplay = dt.zeit2
                    ? `${dt.zeit} + ${dt.zeit2}`
                    : (dt.zeit || '');
                return `
                <div class="legende-item">
                    <span class="schicht-badge" style="background: ${dt.farbe}; color: ${getContrastColor(dt.farbe)}">${dt.code}</span>
                    <span>${dt.name}${zeitDisplay ? ` (${zeitDisplay})` : ''}</span>
                </div>
            `}).join('');
        }

        function getContrastColor(hexcolor) {
            const r = parseInt(hexcolor.slice(1, 3), 16);
            const g = parseInt(hexcolor.slice(3, 5), 16);
            const b = parseInt(hexcolor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5 ? '#333' : '#fff';
        }

        function getDiensttypByCode(code) {
            return dienstplanDiensttypen.find(dt => dt.code === code);
        }

        // ===== ARBEITSSTUNDEN-BERECHNUNG =====
        // Zeit-String parsen (z.B. "6:00-14:30" ‚Üí 510 Minuten)
        function parseTimeRange(zeitStr) {
            if (!zeitStr || !zeitStr.includes('-')) return 0;

            const parts = zeitStr.split('-');
            if (!parts[0] || !parts[1]) return 0;

            const [startH, startM] = parts[0].split(':').map(Number);
            const [endH, endM] = parts[1].split(':').map(Number);

            if (isNaN(startH) || isNaN(endH)) return 0;

            const startMin = startH * 60 + (startM || 0);
            const endMin = endH * 60 + (endM || 0);

            return endMin > startMin ? (endMin - startMin) : 0;
        }

        // Monatsstunden f√ºr einen Mitarbeiter berechnen
        function calculateMonthlyHours(mitarbeiterId) {
            let totalMinutes = 0;
            const daysInMonth = new Date(currentDienstplanYear, currentDienstplanMonth + 1, 0).getDate();

            for (let day = 1; day <= daysInMonth; day++) {
                const datum = `${currentDienstplanYear}-${String(currentDienstplanMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const key = `${mitarbeiterId}_${datum}`;
                const schicht = dienstplanSchichten[key];

                if (schicht?.schichtTyp) {
                    const diensttyp = getDiensttypByCode(schicht.schichtTyp);
                    if (diensttyp) {
                        // Zeit 1 addieren
                        if (diensttyp.zeit) {
                            totalMinutes += parseTimeRange(diensttyp.zeit);
                        }
                        // Zeit 2 addieren (Teildienst)
                        if (diensttyp.zeit2) {
                            totalMinutes += parseTimeRange(diensttyp.zeit2);
                        }
                    }
                }
            }

            const hours = totalMinutes / 60;
            return hours.toFixed(1);
        }

        // ===== DRAG & DROP =====
        function handlePaletteDragStart(e) {
            const diensttyp = e.currentTarget.dataset.diensttyp;
            e.dataTransfer.setData('text/plain', JSON.stringify({
                type: 'new',
                diensttyp: diensttyp
            }));
            e.dataTransfer.effectAllowed = 'copy';
            e.currentTarget.classList.add('dragging');
        }

        function handleSchichtDragStart(e) {
            const mitarbeiterId = e.currentTarget.dataset.mitarbeiterId;
            const datum = e.currentTarget.dataset.datum;
            const diensttyp = e.currentTarget.dataset.diensttyp;

            e.dataTransfer.setData('text/plain', JSON.stringify({
                type: 'move',
                fromMitarbeiter: mitarbeiterId,
                fromDatum: datum,
                diensttyp: diensttyp
            }));
            e.dataTransfer.effectAllowed = 'move';
            e.currentTarget.classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        // ========== FILL-DRAG (Durchziehen wie Excel) ==========
        let fillDragState = {
            active: false,
            diensttyp: null,
            mitarbeiterId: null,
            startDatum: null,
            previewCells: []
        };

        function handleFillStart(e) {
            e.preventDefault();
            e.stopPropagation();
            const handle = e.target;

            fillDragState = {
                active: true,
                diensttyp: handle.dataset.diensttyp,
                mitarbeiterId: handle.dataset.mitarbeiter,
                startDatum: handle.dataset.startDatum,
                previewCells: []
            };

            document.addEventListener('mousemove', handleFillMove);
            document.addEventListener('mouseup', handleFillEnd);
        }

        function handleFillMove(e) {
            if (!fillDragState.active) return;

            const cell = document.elementFromPoint(e.clientX, e.clientY)
                ?.closest('.dienstplan-cell[data-mitarbeiter-id]');

            if (!cell) return;
            if (cell.dataset.mitarbeiterId !== fillDragState.mitarbeiterId) return;

            updateFillPreview(fillDragState.startDatum, cell.dataset.datum);
        }

        function updateFillPreview(startDatum, endDatum) {
            fillDragState.previewCells.forEach(c => c.classList.remove('fill-preview'));
            fillDragState.previewCells = [];

            const start = new Date(startDatum);
            const end = new Date(endDatum);
            const [earlier, later] = start <= end ? [start, end] : [end, start];

            const cells = document.querySelectorAll(
                `.dienstplan-cell[data-mitarbeiter-id="${fillDragState.mitarbeiterId}"]`
            );

            cells.forEach(cell => {
                const cellDate = new Date(cell.dataset.datum);
                if (cellDate >= earlier && cellDate <= later) {
                    cell.classList.add('fill-preview');
                    fillDragState.previewCells.push(cell);
                }
            });
        }

        async function handleFillEnd(e) {
            if (!fillDragState.active) return;

            document.removeEventListener('mousemove', handleFillMove);
            document.removeEventListener('mouseup', handleFillEnd);

            // Alle Preview-Zellen mit Dienst f√ºllen
            const promises = fillDragState.previewCells.map(cell =>
                setSchichtDirect(
                    cell.dataset.mitarbeiterId,
                    cell.dataset.datum,
                    fillDragState.diensttyp
                )
            );

            await Promise.all(promises);

            // Reset
            fillDragState.previewCells.forEach(c => c.classList.remove('fill-preview'));
            fillDragState = { active: false, diensttyp: null, mitarbeiterId: null, startDatum: null, previewCells: [] };

            renderDienstplanKalender();
            console.log('‚úÖ Fill abgeschlossen');
        }
        // ========== ENDE FILL-DRAG ==========

        function setupDropZone(cell) {
            cell.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                cell.classList.add('drag-over');
            });

            cell.addEventListener('dragleave', (e) => {
                if (!cell.contains(e.relatedTarget)) {
                    cell.classList.remove('drag-over');
                }
            });

            cell.addEventListener('drop', handleCellDrop);
        }

        async function handleCellDrop(e) {
            e.preventDefault();
            const cell = e.currentTarget;
            cell.classList.remove('drag-over');

            const mitarbeiterId = cell.dataset.mitarbeiterId;
            const datum = cell.dataset.datum;

            if (!mitarbeiterId || !datum) return;

            try {
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));

                if (data.type === 'new') {
                    // Neuer Dienst aus Palette
                    await setSchichtDirect(mitarbeiterId, datum, data.diensttyp);
                } else if (data.type === 'move') {
                    // Verschieben innerhalb Kalender
                    await moveSchicht(data.fromMitarbeiter, data.fromDatum, mitarbeiterId, datum, data.diensttyp);
                }
            } catch (error) {
                console.error('Drop error:', error);
            }
        }

        async function setSchichtDirect(mitarbeiterId, datum, schichtTyp) {
            const key = `${mitarbeiterId}_${datum}`;

            try {
                const { collection, doc, setDoc } = window.firebaseModules;
                const schichtData = { mitarbeiterId, datum, schichtTyp };

                if (dienstplanSchichten[key]?.id) {
                    await setDoc(doc(window.firestoreDB, 'dienstplan_schichten', dienstplanSchichten[key].id), schichtData);
                    dienstplanSchichten[key] = { id: dienstplanSchichten[key].id, ...schichtData };
                } else {
                    const newDocRef = doc(collection(window.firestoreDB, 'dienstplan_schichten'));
                    await setDoc(newDocRef, schichtData);
                    dienstplanSchichten[key] = { id: newDocRef.id, ...schichtData };
                }

                renderDienstplanKalender();
                console.log('‚úÖ Schicht gesetzt:', key, schichtTyp);
            } catch (error) {
                console.error('Fehler:', error);
            }
        }

        async function moveSchicht(fromMitarbeiter, fromDatum, toMitarbeiter, toDatum, schichtTyp) {
            const fromKey = `${fromMitarbeiter}_${fromDatum}`;
            const toKey = `${toMitarbeiter}_${toDatum}`;

            // Gleiche Zelle = nichts tun
            if (fromKey === toKey) return;

            try {
                const { collection, doc, setDoc, deleteDoc } = window.firebaseModules;

                // Alte Schicht l√∂schen
                if (dienstplanSchichten[fromKey]?.id) {
                    await deleteDoc(doc(window.firestoreDB, 'dienstplan_schichten', dienstplanSchichten[fromKey].id));
                    delete dienstplanSchichten[fromKey];
                }

                // Neue Schicht erstellen
                const schichtData = { mitarbeiterId: toMitarbeiter, datum: toDatum, schichtTyp };
                if (dienstplanSchichten[toKey]?.id) {
                    await setDoc(doc(window.firestoreDB, 'dienstplan_schichten', dienstplanSchichten[toKey].id), schichtData);
                    dienstplanSchichten[toKey] = { id: dienstplanSchichten[toKey].id, ...schichtData };
                } else {
                    const newDocRef = doc(collection(window.firestoreDB, 'dienstplan_schichten'));
                    await setDoc(newDocRef, schichtData);
                    dienstplanSchichten[toKey] = { id: newDocRef.id, ...schichtData };
                }

                renderDienstplanKalender();
                console.log('‚úÖ Schicht verschoben:', fromKey, '‚Üí', toKey);
            } catch (error) {
                console.error('Fehler beim Verschieben:', error);
            }
        }

        // ===== DIENSTTYPEN MODAL =====
        function openDiensttypenModal() {
            renderDiensttypenListe();
            document.getElementById('diensttypenModal').classList.add('active');
        }

        function closeDiensttypenModal() {
            document.getElementById('diensttypenModal').classList.remove('active');
        }

        function renderDiensttypenListe() {
            const container = document.getElementById('diensttypenListe');
            if (!container) return;

            container.innerHTML = dienstplanDiensttypen.map(dt => `
                <div class="diensttyp-item">
                    <div class="diensttyp-preview">
                        <span class="schicht-badge" style="background: ${dt.farbe}; color: ${getContrastColor(dt.farbe)}">${dt.code}</span>
                        <div class="diensttyp-info">
                            <span class="diensttyp-name">${dt.name}</span>
                            <span class="diensttyp-zeit">${dt.zeit || 'Keine Zeitangabe'}</span>
                        </div>
                    </div>
                    <div class="diensttyp-actions">
                        <button class="btn btn-sm btn-secondary" onclick="editDiensttyp('${dt.id}')">‚úèÔ∏è</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteDiensttyp('${dt.id}')">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function addNewDiensttyp() {
            document.getElementById('dt_id').value = '';
            document.getElementById('dt_code').value = '';
            document.getElementById('dt_name').value = '';
            document.getElementById('dt_zeit').value = '';
            document.getElementById('dt_zeit2').value = '';
            document.getElementById('dt_farbe').value = '#3498db';
            document.getElementById('dt_farbe_hex').textContent = '#3498db';
            document.getElementById('diensttypEditTitle').textContent = 'Neuer Diensttyp';
            document.getElementById('diensttypEditModal').classList.add('active');
        }

        function editDiensttyp(id) {
            const dt = dienstplanDiensttypen.find(d => d.id === id);
            if (!dt) return;

            document.getElementById('dt_id').value = dt.id;
            document.getElementById('dt_code').value = dt.code;
            document.getElementById('dt_name').value = dt.name;
            document.getElementById('dt_zeit').value = dt.zeit || '';
            document.getElementById('dt_zeit2').value = dt.zeit2 || '';
            document.getElementById('dt_farbe').value = dt.farbe;
            document.getElementById('dt_farbe_hex').textContent = dt.farbe;
            document.getElementById('diensttypEditTitle').textContent = 'Diensttyp bearbeiten';
            document.getElementById('diensttypEditModal').classList.add('active');
        }

        function closeDiensttypEditModal() {
            document.getElementById('diensttypEditModal').classList.remove('active');
        }

        async function saveDiensttyp(event) {
            event.preventDefault();

            const id = document.getElementById('dt_id').value;
            const data = {
                code: document.getElementById('dt_code').value.toUpperCase(),
                name: document.getElementById('dt_name').value,
                zeit: document.getElementById('dt_zeit').value,
                zeit2: document.getElementById('dt_zeit2').value,
                farbe: document.getElementById('dt_farbe').value,
                reihenfolge: id ? (dienstplanDiensttypen.find(d => d.id === id)?.reihenfolge || 99) : dienstplanDiensttypen.length + 1
            };

            try {
                const { collection, doc, setDoc } = window.firebaseModules;

                if (id) {
                    await setDoc(doc(window.firestoreDB, 'dienstplan_diensttypen', id), data);
                    const idx = dienstplanDiensttypen.findIndex(d => d.id === id);
                    if (idx !== -1) dienstplanDiensttypen[idx] = { id, ...data };
                } else {
                    const newDocRef = doc(collection(window.firestoreDB, 'dienstplan_diensttypen'));
                    await setDoc(newDocRef, data);
                    dienstplanDiensttypen.push({ id: newDocRef.id, ...data });
                }

                closeDiensttypEditModal();
                renderDiensttypenListe();
                renderDiensttypenPalette();
                renderDienstplanLegende();
                renderDienstplanKalender();
                console.log('‚úÖ Diensttyp gespeichert');
            } catch (error) {
                console.error('Fehler:', error);
                alert('Fehler: ' + error.message);
            }
        }

        async function deleteDiensttyp(id) {
            if (!confirm('Diensttyp wirklich l√∂schen?')) return;

            try {
                const { doc, deleteDoc } = window.firebaseModules;
                await deleteDoc(doc(window.firestoreDB, 'dienstplan_diensttypen', id));

                dienstplanDiensttypen = dienstplanDiensttypen.filter(d => d.id !== id);
                renderDiensttypenListe();
                renderDiensttypenPalette();
                renderDienstplanLegende();
                console.log('‚úÖ Diensttyp gel√∂scht');
            } catch (error) {
                console.error('Fehler:', error);
            }
        }

        // Mitarbeiter aus Firestore laden
        async function loadDienstplanMitarbeiter() {
            try {
                const { collection, getDocs, query, orderBy } = window.firebaseModules;
                const mitarbeiterRef = collection(window.firestoreDB, 'dienstplan_mitarbeiter');
                const q = query(mitarbeiterRef, orderBy('reihenfolge', 'asc'));
                const snapshot = await getDocs(q);

                dienstplanMitarbeiter = [];
                snapshot.forEach(doc => {
                    dienstplanMitarbeiter.push({ id: doc.id, ...doc.data() });
                });

                // Falls keine Mitarbeiter existieren, Standard-Mitarbeiter anlegen
                if (dienstplanMitarbeiter.length === 0) {
                    await createDefaultMitarbeiter();
                }

                console.log('‚úÖ Dienstplan Mitarbeiter geladen:', dienstplanMitarbeiter.length);
            } catch (error) {
                console.error('Fehler beim Laden der Mitarbeiter:', error);
            }
        }

        // Standard-Mitarbeiter anlegen
        async function createDefaultMitarbeiter() {
            const defaults = [
                { name: 'Marcel', rolle: 'CHEF', prozent: 100, reihenfolge: 1 },
                { name: 'Guillem', rolle: 'Souschef', prozent: 100, reihenfolge: 2 },
                { name: 'Marcelo', rolle: 'Koch', prozent: 80, reihenfolge: 3 },
                { name: 'Gerard', rolle: 'Koch', prozent: 80, reihenfolge: 4 },
                { name: 'Melitza', rolle: 'Koch', prozent: 80, reihenfolge: 5 },
                { name: 'Kevin', rolle: 'Aushilfe', prozent: 40, reihenfolge: 6 }
            ];

            const { collection, doc, setDoc } = window.firebaseModules;

            for (const ma of defaults) {
                const newDocRef = doc(collection(window.firestoreDB, 'dienstplan_mitarbeiter'));
                await setDoc(newDocRef, ma);
                dienstplanMitarbeiter.push({ id: newDocRef.id, ...ma });
            }

            console.log('‚úÖ Standard-Mitarbeiter angelegt');
        }

        // Schichten f√ºr aktuellen Monat laden
        async function loadDienstplan() {
            currentDienstplanMonth = parseInt(document.getElementById('dienstplanMonat')?.value || currentDienstplanMonth);
            currentDienstplanYear = parseInt(document.getElementById('dienstplanJahr')?.value || currentDienstplanYear);

            try {
                const { collection, getDocs, query, where } = window.firebaseModules;
                const schichtenRef = collection(window.firestoreDB, 'dienstplan_schichten');

                // Alle Schichten f√ºr diesen Monat laden
                const startDatum = `${currentDienstplanYear}-${String(currentDienstplanMonth + 1).padStart(2, '0')}-01`;
                const endDatum = `${currentDienstplanYear}-${String(currentDienstplanMonth + 1).padStart(2, '0')}-31`;

                const snapshot = await getDocs(schichtenRef);

                dienstplanSchichten = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    // Nur Schichten des aktuellen Monats
                    if (data.datum >= startDatum && data.datum <= endDatum) {
                        const key = `${data.mitarbeiterId}_${data.datum}`;
                        dienstplanSchichten[key] = { id: doc.id, ...data };
                    }
                });

                renderDienstplanKalender();
                console.log('‚úÖ Dienstplan geladen f√ºr', MONATE[currentDienstplanMonth], currentDienstplanYear);
            } catch (error) {
                console.error('Fehler beim Laden des Dienstplans:', error);
            }
        }

        // Kalender rendern
        function renderDienstplanKalender() {
            const container = document.getElementById('dienstplanKalender');
            if (!container) return;

            const daysInMonth = new Date(currentDienstplanYear, currentDienstplanMonth + 1, 0).getDate();
            const totalCols = daysInMonth + 3; // Name + WT + Std + Tage

            container.style.gridTemplateColumns = `120px 35px 45px repeat(${daysInMonth}, 40px)`;
            // Dynamische min-width basierend auf Tagen im Monat
            const minWidth = 120 + 35 + 45 + (daysInMonth * 40) + 20; // +20 f√ºr Puffer
            container.style.minWidth = `${minWidth}px`;

            let html = '';

            // Header-Zeile 1: Wochentage
            html += '<div class="dienstplan-header">';
            html += '<div class="dienstplan-header-cell name-col">Name/Datum</div>';
            html += '<div class="dienstplan-header-cell wt-col">WT</div>';
            html += '<div class="dienstplan-header-cell std-col">Std</div>';

            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(currentDienstplanYear, currentDienstplanMonth, day);
                const weekday = date.getDay();
                const isWeekend = weekday === 0 || weekday === 6;
                html += `<div class="dienstplan-header-cell day-col ${isWeekend ? 'weekend' : ''}">${WOCHENTAGE[weekday]}</div>`;
            }
            html += '</div>';

            // Header-Zeile 2: Tagesnummern
            html += '<div class="dienstplan-row">';
            html += '<div class="dienstplan-cell day-number name-cell"></div>';
            html += '<div class="dienstplan-cell day-number wt-cell">%</div>';
            html += '<div class="dienstplan-cell day-number std-cell">h</div>';

            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(currentDienstplanYear, currentDienstplanMonth, day);
                const isWeekend = date.getDay() === 0 || date.getDay() === 6;
                html += `<div class="dienstplan-cell day-number ${isWeekend ? 'weekend' : ''}">${day}</div>`;
            }
            html += '</div>';

            // Mitarbeiter-Zeilen
            for (const ma of dienstplanMitarbeiter) {
                html += '<div class="dienstplan-row">';
                html += `<div class="dienstplan-cell name-cell">${ma.name}${ma.rolle === 'CHEF' ? ' üë®‚Äçüç≥' : ''}</div>`;
                html += `<div class="dienstplan-cell wt-cell">${ma.prozent || 100}</div>`;
                const monatsstunden = calculateMonthlyHours(ma.id);
                html += `<div class="dienstplan-cell std-cell">${monatsstunden}h</div>`;

                for (let day = 1; day <= daysInMonth; day++) {
                    const datum = `${currentDienstplanYear}-${String(currentDienstplanMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const date = new Date(currentDienstplanYear, currentDienstplanMonth, day);
                    const isWeekend = date.getDay() === 0 || date.getDay() === 6;

                    const key = `${ma.id}_${datum}`;
                    const schicht = dienstplanSchichten[key];
                    const schichtTyp = schicht?.schichtTyp || '';

                    // Dynamische Farben aus Diensttypen
                    let badgeHtml = '';
                    if (schichtTyp) {
                        const dt = getDiensttypByCode(schichtTyp);
                        const bgColor = dt?.farbe || '#6c757d';
                        const textColor = getContrastColor(bgColor);
                        badgeHtml = `<span class="schicht-badge"
                                          style="background: ${bgColor}; color: ${textColor}; position: relative;"
                                          draggable="true"
                                          data-diensttyp="${schichtTyp}"
                                          data-from-mitarbeiter="${ma.id}"
                                          data-from-datum="${datum}">${schichtTyp}<span class="fill-handle"
                                              data-diensttyp="${schichtTyp}"
                                              data-mitarbeiter="${ma.id}"
                                              data-start-datum="${datum}"></span></span>`;
                    }

                    html += `<div class="dienstplan-cell ${isWeekend ? 'weekend' : ''}"
                                  data-mitarbeiter-id="${ma.id}"
                                  data-datum="${datum}"
                                  data-mitarbeiter-name="${ma.name}">${badgeHtml}</div>`;
                }
                html += '</div>';
            }

            container.innerHTML = html;

            // Drop-Zones auf Zellen einrichten
            container.querySelectorAll('.dienstplan-cell[data-mitarbeiter-id]').forEach(cell => {
                setupDropZone(cell);
                // Click-Handler f√ºr Modal (als Fallback)
                cell.addEventListener('click', (e) => {
                    if (e.target.classList.contains('schicht-badge')) return; // Badge geklickt, nicht Zelle
                    openSchichtModal(cell.dataset.mitarbeiterId, cell.dataset.datum, cell.dataset.mitarbeiterName);
                });
            });

            // Bestehende Schicht-Badges draggable machen
            container.querySelectorAll('.schicht-badge[draggable="true"]').forEach(badge => {
                badge.addEventListener('dragstart', handleSchichtDragStart);
                badge.addEventListener('dragend', handleDragEnd);
            });

            // Fill-Handle Events (Durchziehen)
            container.querySelectorAll('.fill-handle').forEach(handle => {
                handle.addEventListener('mousedown', handleFillStart);
            });
        }

        // Schicht-Auswahl dynamisch rendern
        function renderSchichtAuswahl() {
            const container = document.getElementById('schichtAuswahlContainer');
            if (!container) return;

            // Diensttypen-Buttons rendern
            const sortedTypes = [...dienstplanDiensttypen].sort((a, b) => (a.reihenfolge || 99) - (b.reihenfolge || 99));
            let html = sortedTypes.map(dt => {
                const textColor = getContrastColor(dt.farbe);
                return `<button class="schicht-btn" onclick="setSchicht('${dt.code}')"
                                style="background: ${dt.farbe}; color: ${textColor}; border: 2px solid ${dt.farbe}">
                            ${dt.code}<br><small>${dt.name}</small>
                        </button>`;
            }).join('');

            // L√∂schen-Button hinzuf√ºgen
            html += `<button class="schicht-btn" onclick="setSchicht('')"
                             style="background: #e9ecef; color: #6c757d; border: 2px solid #dee2e6">
                        ‚úï<br><small>L√∂schen</small>
                    </button>`;

            container.innerHTML = html;
        }

        // Schicht-Modal √∂ffnen
        function openSchichtModal(mitarbeiterId, datum, mitarbeiterName) {
            document.getElementById('schicht_mitarbeiter_id').value = mitarbeiterId;
            document.getElementById('schicht_datum').value = datum;

            // Titel mit Datum und Name
            const dateObj = new Date(datum);
            const formattedDate = `${dateObj.getDate()}. ${MONATE[dateObj.getMonth()]} ${dateObj.getFullYear()}`;
            document.getElementById('schichtModalTitle').textContent = `${mitarbeiterName} - ${formattedDate}`;

            // Buttons dynamisch rendern
            renderSchichtAuswahl();

            document.getElementById('schichtModal').classList.add('active');
        }

        function closeSchichtModal() {
            document.getElementById('schichtModal').classList.remove('active');
        }

        // Schicht setzen/aktualisieren
        async function setSchicht(schichtTyp) {
            const mitarbeiterId = document.getElementById('schicht_mitarbeiter_id').value;
            const datum = document.getElementById('schicht_datum').value;

            if (!mitarbeiterId || !datum) return;

            const key = `${mitarbeiterId}_${datum}`;

            try {
                const { collection, doc, setDoc, deleteDoc } = window.firebaseModules;

                if (schichtTyp === '') {
                    // Schicht l√∂schen
                    if (dienstplanSchichten[key]?.id) {
                        await deleteDoc(doc(window.firestoreDB, 'dienstplan_schichten', dienstplanSchichten[key].id));
                        delete dienstplanSchichten[key];
                    }
                } else {
                    // Schicht setzen/aktualisieren
                    const schichtData = {
                        mitarbeiterId,
                        datum,
                        schichtTyp
                    };

                    if (dienstplanSchichten[key]?.id) {
                        // Update
                        await setDoc(doc(window.firestoreDB, 'dienstplan_schichten', dienstplanSchichten[key].id), schichtData);
                        dienstplanSchichten[key] = { id: dienstplanSchichten[key].id, ...schichtData };
                    } else {
                        // Neu erstellen
                        const newDocRef = doc(collection(window.firestoreDB, 'dienstplan_schichten'));
                        await setDoc(newDocRef, schichtData);
                        dienstplanSchichten[key] = { id: newDocRef.id, ...schichtData };
                    }
                }

                closeSchichtModal();
                renderDienstplanKalender();
                console.log('‚úÖ Schicht gespeichert:', key, schichtTyp);
            } catch (error) {
                console.error('Fehler beim Speichern der Schicht:', error);
                alert('Fehler beim Speichern: ' + error.message);
            }
        }

        // Monatsnavigation
        function prevMonth() {
            currentDienstplanMonth--;
            if (currentDienstplanMonth < 0) {
                currentDienstplanMonth = 11;
                currentDienstplanYear--;
            }
            document.getElementById('dienstplanMonat').value = currentDienstplanMonth;
            document.getElementById('dienstplanJahr').value = currentDienstplanYear;
            loadDienstplan();
        }

        function nextMonth() {
            currentDienstplanMonth++;
            if (currentDienstplanMonth > 11) {
                currentDienstplanMonth = 0;
                currentDienstplanYear++;
            }
            document.getElementById('dienstplanMonat').value = currentDienstplanMonth;
            document.getElementById('dienstplanJahr').value = currentDienstplanYear;
            loadDienstplan();
        }

        // PDF Export
        function exportDienstplanPDF() {
            // Monat und Jahr f√ºr Titel
            const monatName = MONATE[currentDienstplanMonth];
            const jahr = currentDienstplanYear;

            // Print-Container erstellen
            const printWindow = window.open('', '_blank');

            // Kalender HTML holen
            const kalenderHTML = document.getElementById('dienstplanKalender').outerHTML;

            // Legende HTML erstellen
            let legendeHTML = '<div class="print-legende"><div class="print-legende-title">Legende:</div><div class="print-legende-items">';
            dienstplanDiensttypen.forEach(dt => {
                const zeitDisplay = dt.zeit2 ? `${dt.zeit} + ${dt.zeit2}` : (dt.zeit || '');
                legendeHTML += `<div class="print-legende-item">
                    <span style="display: inline-block; width: 24px; height: 16px; background: ${dt.farbe}; border-radius: 3px; text-align: center; color: white; font-size: 10px; line-height: 16px;">${dt.code}</span>
                    <span>${dt.name}${zeitDisplay ? ` (${zeitDisplay})` : ''}</span>
                </div>`;
            });
            legendeHTML += '</div></div>';

            // Print-Dokument erstellen
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Dienstplan ${monatName} ${jahr}</title>
                    <style>
                        * { box-sizing: border-box; margin: 0; padding: 0; }
                        body { font-family: Arial, sans-serif; padding: 20px; }

                        .print-header {
                            text-align: center;
                            margin-bottom: 20px;
                            padding-bottom: 10px;
                            border-bottom: 2px solid #333;
                        }
                        .print-header h1 { font-size: 20px; margin-bottom: 5px; }
                        .print-header p { font-size: 12px; color: #666; }

                        .dienstplan-kalender {
                            display: grid;
                            grid-template-columns: 120px 35px 45px repeat(31, 38px);
                            border: 1px solid #ddd;
                            font-size: 10px;
                        }

                        .dienstplan-header { display: contents; }
                        .dienstplan-row { display: contents; }

                        .dienstplan-header-cell {
                            background: #2c3e50;
                            color: white;
                            padding: 4px;
                            text-align: center;
                            font-weight: bold;
                            border: 1px solid #ddd;
                        }

                        .dienstplan-cell {
                            padding: 3px;
                            text-align: center;
                            border: 1px solid #eee;
                            min-height: 24px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        }

                        .dienstplan-cell.name-cell {
                            text-align: left;
                            justify-content: flex-start;
                            font-weight: bold;
                            background: #f8f9fa;
                        }

                        .dienstplan-cell.wt-cell,
                        .dienstplan-cell.std-cell {
                            font-size: 9px;
                            color: #666;
                        }

                        .dienstplan-cell.std-cell {
                            color: #27ae60;
                            font-weight: bold;
                        }

                        .dienstplan-cell.weekend {
                            background: #f5f5f5;
                        }

                        .dienstplan-cell.day-number {
                            background: #e9ecef;
                            font-weight: bold;
                        }

                        .schicht-badge {
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            padding: 2px 4px;
                            border-radius: 3px;
                            font-size: 9px;
                            font-weight: bold;
                            min-width: 22px;
                        }

                        .fill-handle { display: none; }

                        .print-legende {
                            margin-top: 20px;
                            padding-top: 15px;
                            border-top: 1px solid #ddd;
                        }

                        .print-legende-title {
                            font-weight: bold;
                            margin-bottom: 10px;
                            font-size: 12px;
                        }

                        .print-legende-items {
                            display: flex;
                            flex-wrap: wrap;
                            gap: 15px;
                        }

                        .print-legende-item {
                            display: flex;
                            align-items: center;
                            gap: 5px;
                            font-size: 10px;
                        }

                        @media print {
                            @page { size: landscape; margin: 8mm; }
                        }
                    </style>
                </head>
                <body>
                    <div class="print-header">
                        <h1>Dienstplan - ${monatName} ${jahr}</h1>
                        <p>DAKOTA Hotel & Restaurant</p>
                    </div>
                    ${kalenderHTML}
                    ${legendeHTML}
                    <script>
                        window.onload = function() {
                            setTimeout(function() {
                                window.print();
                            }, 500);
                        };
                    <\/script>
                </body>
                </html>
            `);

            printWindow.document.close();
            console.log('üìÑ PDF Export gestartet');
        }

        // Mitarbeiter-Modal
        function openMitarbeiterModal() {
            renderMitarbeiterListe();
            document.getElementById('mitarbeiterModal').classList.add('active');
        }

        function closeMitarbeiterModal() {
            document.getElementById('mitarbeiterModal').classList.remove('active');
        }

        function renderMitarbeiterListe() {
            const container = document.getElementById('mitarbeiterListe');
            if (!container) return;

            container.innerHTML = dienstplanMitarbeiter.map(ma => `
                <div class="mitarbeiter-item">
                    <div class="mitarbeiter-info">
                        <span class="mitarbeiter-name">${ma.name}</span>
                        <span class="mitarbeiter-rolle">${ma.rolle || 'Koch'} - ${ma.prozent || 100}%</span>
                    </div>
                    <div class="mitarbeiter-actions">
                        <button class="btn btn-sm btn-secondary" onclick="editMitarbeiter('${ma.id}')">‚úèÔ∏è</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteMitarbeiter('${ma.id}')">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function addNewMitarbeiter() {
            document.getElementById('ma_id').value = '';
            document.getElementById('ma_name').value = '';
            document.getElementById('ma_rolle').value = 'Koch';
            document.getElementById('ma_prozent').value = 100;
            document.getElementById('mitarbeiterEditTitle').textContent = 'Neuer Mitarbeiter';
            document.getElementById('mitarbeiterEditModal').classList.add('active');
        }

        function editMitarbeiter(id) {
            const ma = dienstplanMitarbeiter.find(m => m.id === id);
            if (!ma) return;

            document.getElementById('ma_id').value = ma.id;
            document.getElementById('ma_name').value = ma.name;
            document.getElementById('ma_rolle').value = ma.rolle || 'Koch';
            document.getElementById('ma_prozent').value = ma.prozent || 100;
            document.getElementById('mitarbeiterEditTitle').textContent = 'Mitarbeiter bearbeiten';
            document.getElementById('mitarbeiterEditModal').classList.add('active');
        }

        function closeMitarbeiterEditModal() {
            document.getElementById('mitarbeiterEditModal').classList.remove('active');
        }

        async function saveMitarbeiter(event) {
            event.preventDefault();

            const id = document.getElementById('ma_id').value;
            const data = {
                name: document.getElementById('ma_name').value,
                rolle: document.getElementById('ma_rolle').value,
                prozent: parseInt(document.getElementById('ma_prozent').value) || 100,
                reihenfolge: id ? (dienstplanMitarbeiter.find(m => m.id === id)?.reihenfolge || 99) : dienstplanMitarbeiter.length + 1
            };

            try {
                const { collection, doc, setDoc } = window.firebaseModules;

                if (id) {
                    // Update
                    await setDoc(doc(window.firestoreDB, 'dienstplan_mitarbeiter', id), data);
                    const idx = dienstplanMitarbeiter.findIndex(m => m.id === id);
                    if (idx !== -1) {
                        dienstplanMitarbeiter[idx] = { id, ...data };
                    }
                } else {
                    // Neu
                    const newDocRef = doc(collection(window.firestoreDB, 'dienstplan_mitarbeiter'));
                    await setDoc(newDocRef, data);
                    dienstplanMitarbeiter.push({ id: newDocRef.id, ...data });
                }

                closeMitarbeiterEditModal();
                renderMitarbeiterListe();
                renderDienstplanKalender();
                console.log('‚úÖ Mitarbeiter gespeichert');
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
                alert('Fehler: ' + error.message);
            }
        }

        async function deleteMitarbeiter(id) {
            if (!confirm('Mitarbeiter wirklich l√∂schen?')) return;

            try {
                const { doc, deleteDoc } = window.firebaseModules;
                await deleteDoc(doc(window.firestoreDB, 'dienstplan_mitarbeiter', id));

                dienstplanMitarbeiter = dienstplanMitarbeiter.filter(m => m.id !== id);
                renderMitarbeiterListe();
                renderDienstplanKalender();
                console.log('‚úÖ Mitarbeiter gel√∂scht');
            } catch (error) {
                console.error('Fehler beim L√∂schen:', error);
                alert('Fehler: ' + error.message);
            }
        }

        // ===== INIT APP =====
        async function initApp() {
            try {
                await initDB();
                await loadLebensmittel();
                await loadRezepte();
                await loadMenuekarten(); // FIX: Men√ºkarten VOR Firebase-Migration laden!
                updateStats();

                // Auto-Import NUR beim allerersten Start (EINMALIG!)
                const autoImportDone = localStorage.getItem('dakota_auto_import_done');
                const firestoreMigrated = localStorage.getItem('firestore_migrated');

                // NEU: Auto-Import von Firebase (statt embedded Datenbank)
                // Nur importieren wenn ALLE Bedingungen erf√ºllt:
                // 1. Noch nie importiert (!autoImportDone)
                // 2. IndexedDB ist leer (lebensmittelData.length === 0)
                if (!autoImportDone && lebensmittelData.length === 0) {
                    console.log('üéâ Erste Installation erkannt - starte Auto-Import von Firebase...');

                    // NEU: Von Firebase laden (statt embedded Datenbank)
                    const success = await autoImportFromFirestore();

                    if (success) {
                        localStorage.setItem('dakota_auto_import_done', 'true');
                        console.log('‚úÖ Firebase Auto-Import abgeschlossen und als durchgef√ºhrt markiert');
                    } else {
                        console.log('‚ö†Ô∏è Firebase Auto-Import fehlgeschlagen - nutze JSON-Import als Fallback');
                        // Bei Fehler wird der User in autoImportFromFirestore() bereits informiert
                        // und die Import-Buttons werden sichtbar gelassen
                    }
                } else {
                    if (autoImportDone) {
                        console.log('‚úì Auto-Import bereits durchgef√ºhrt (dakota_auto_import_done = true)');
                    }
                    if (firestoreMigrated) {
                        console.log('‚úì Firestore-Daten vorhanden, kein Auto-Import n√∂tig');
                    }
                    if (lebensmittelData.length > 0) {
                        console.log(`‚úì ${lebensmittelData.length} Lebensmittel in IndexedDB vorhanden`);
                    }
                }

                // FIX 3: Migration - Repariere Lebensmittel ohne gastro_id
                // L√§uft nach jedem Start, aber nur wenn n√∂tig
                await migrateLebensmittelGastroIds();

                // üî• FIREBASE/FIRESTORE SYNC INITIALISIEREN
                // Startet Echtzeit-Synchronisation mit Cloud-Datenbank
                // Migriert alle 3 Collections: lebensmittel, rezepte, menuekarten
                await initFirestoreSync();

                // üîç GLOBAL SEARCH INITIALISIEREN
                initGlobalSearch();
            } catch (error) {
                console.error('Error initializing app:', error);
                alert('Fehler beim Laden der Datenbank: ' + error.message);
            }
        }

        // Start app when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);
    </script>

    <!-- REZEPT DETAIL MODAL -->
    <div id="rezeptModal" class="rezept-modal">
        <div class="rezept-modal-content">
            <div class="rezept-modal-header">
                <button class="rezept-modal-close" onclick="closeRezeptDetailModal()">&times;</button>
                <h2 class="rezept-modal-title" id="modalRezeptName"></h2>
                <div class="rezept-modal-meta" id="modalRezeptMeta"></div>
            </div>
            <div class="rezept-modal-body">
                <!-- Kosten-Zusammenfassung -->
                <div class="rezept-cost-summary" id="modalCostSummary"></div>

                <!-- Zutaten -->
                <div class="rezept-modal-section">
                    <h3 class="rezept-modal-section-title">ü•ò Zutaten</h3>
                    <div class="rezept-zutaten-list" id="modalZutatenList"></div>
                </div>

                <!-- Zubereitung -->
                <div class="rezept-modal-section" id="modalZubereitungSection">
                    <h3 class="rezept-modal-section-title">üë®‚Äçüç≥ Zubereitung</h3>
                    <ol class="rezept-zubereitung-list" id="modalZubereitungList"></ol>
                </div>

                <!-- Bemerkung -->
                <div class="rezept-modal-section" id="modalBemerkungSection" style="display: none;">
                    <div class="rezept-bemerkung" id="modalBemerkung"></div>
                </div>

                <!-- Quelle -->
                <div class="rezept-quelle" id="modalQuelle"></div>
            </div>
        </div>
    </div>

</body>

</html>